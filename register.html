<!DOCTYPE html>
<html lang="en" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Last-Modified" content="0">
  <title>Register - IAMPHOENIX</title>
  
  <script>
    function parseFloatSafe(text){
      if (!text) return NaN;
      try { return parseFloat(String(text).replace(/[^0-9.]/g,'')); } catch { return NaN; }
    }

    function enforceRegisterButtonState(){
      try {
        const btn = document.getElementById('register-btn');
        const status = document.getElementById('status-message');
        const buyBox = document.getElementById('buy-section');
        const shortageEl = document.getElementById('iam-shortage');
        const buyInput = document.getElementById('buy-dai-amount');
        const buyBtn = document.getElementById('direct-buy-btn');
        const buyHelper = document.getElementById('buy-dai-helper');
        const requiredText = document.getElementById('buy-required-iam')?.textContent || document.getElementById('required-cost-text')?.textContent || '';
        const required = parseFloatSafe(requiredText);
        const iamBalText = document.getElementById('IAM-balance')?.textContent || document.getElementById('buy-current-iam')?.textContent || '';
        const daiBalText = document.getElementById('buy-dai-balance')?.textContent || document.getElementById('quick-swap-dai-balance')?.textContent || '';
        const iamBal = parseFloatSafe(iamBalText);
        const daiBal = parseFloatSafe(daiBalText);
        // Calculate actual need (required - current balance)
        const need = Math.max(0, (isFinite(required) && isFinite(iamBal) ? required - iamBal : 0));
        
        // Check if wallet is connected
        const walletConnected = window.ethereum && (window.contractConfig && window.contractConfig.address);
        
        // If balances are not loaded yet (textContent is empty or "..."), don't show error yet
        const balancesNotLoaded = (!iamBalText || iamBalText === '...' || iamBalText === 'N/A') && 
                                   (!daiBalText || daiBalText === '...' || daiBalText === 'N/A');
        
        // If both balances are effectively zero/unknown and wallet is not connected
        if (!walletConnected) {
          if (btn) { btn.disabled = true; btn.style.opacity = '0.5'; }
          if (buyBtn) { buyBtn.disabled = true; buyBtn.style.opacity = '0.5'; buyBtn.style.cursor = 'not-allowed'; }
          if (buyInput) { buyInput.disabled = true; buyInput.style.opacity = '0.5'; buyInput.style.cursor = 'not-allowed'; }
          if (status && !balancesNotLoaded) {
            status.style.color = '#ff6b6b';
            status.textContent = 'Please connect your wallet first.';
          }
          return;
        }
        
        // If wallet is connected but both balances are zero
        if (walletConnected && isFinite(iamBal) && isFinite(daiBal) && iamBal <= 0 && daiBal <= 0) {
          if (btn) { btn.disabled = true; btn.style.opacity = '0.5'; }
          if (buyBtn) { buyBtn.disabled = true; buyBtn.style.opacity = '0.5'; buyBtn.style.cursor = 'not-allowed'; }
          if (buyInput) { buyInput.disabled = true; buyInput.style.opacity = '0.5'; buyInput.style.cursor = 'not-allowed'; }
          if (status) {
            status.style.color = '#ff6b6b';
            status.textContent = 'Wallet connected. Please fund your wallet with DAI to purchase IAM tokens.';
          }
          return;
        }
        
        // If balances are not loaded yet, don't change state
        if (balancesNotLoaded) {
          return;
        }
        // If required amount is not available yet, don't change button state
        if (!isFinite(required) || required <= 0) { return; }
        // If IAM balance is not available yet, wait for it to load
        if (!isFinite(iamBal)) { return; }
        if (need > 0) {
          // Insufficient balance - enable register form
          if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; }
          if (status) { status.style.color = '#ff6b6b'; status.textContent = `Insufficient IAM balance. Need ${need.toFixed(2)} IAM.`; }
          // Enable buy box with shortage
          if (buyBox && shortageEl) {
            shortageEl.textContent = need.toFixed(2);
            // enable controls
            if (buyInput) { buyInput.disabled = false; buyInput.style.opacity = '1'; buyInput.style.cursor = 'text'; }
            if (buyBtn) { buyBtn.disabled = false; buyBtn.style.opacity = '1'; buyBtn.style.cursor = 'pointer'; }
            if (buyHelper) { buyHelper.textContent = 'Suggested for shortage'; }
            try { updateBuyEstimates(); } catch(_) {}
          }
          // Enable register form inputs
          const registerForm = document.getElementById('register-section');
          if (registerForm) {
            const formInputs = registerForm.querySelectorAll('input, button, select');
            formInputs.forEach(input => {
              if (input.id !== 'register-btn') { // Keep register button disabled when need > 0
                input.disabled = false;
                input.style.opacity = '1';
                input.style.cursor = input.type === 'button' ? 'pointer' : 'text';
              }
            });
          }
        } else {
          // Balance sufficient - enable Register button
          if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; }
          if (status) { status.style.color = '#00ff88'; status.textContent = '✅ IAM balance is sufficient. You can register now.'; }
          // Disable buy controls (balance sufficient)
          if (buyInput) { buyInput.disabled = true; buyInput.style.opacity = '0.5'; buyInput.style.cursor = 'not-allowed'; }
          if (buyBtn) { buyBtn.disabled = true; buyBtn.style.opacity = '0.5'; buyBtn.style.cursor = 'not-allowed'; }
          if (buyHelper) { buyHelper.textContent = 'Balance sufficient — buying disabled'; }
          // Keep register form inputs enabled for edits (no disabling here)
        }
      } catch {}
    }
    // Ensure global access across all inline scripts
    try { window.enforceRegisterButtonState = enforceRegisterButtonState; } catch(_) {}
    // Suppress noisy MetaMask RPC messages that don't affect functionality
    window.addEventListener('error', function(e){
      const m = (e && e.message) || '';
      if (m.includes('getEnabledChains') || m.includes('isDefaultWallet') || m.includes('Could not establish connection') || m.includes('Internal JSON-RPC error') || m.includes('Receiving end does not exist') || m.includes('Extension context invalidated')) { 
        e.preventDefault(); 
        e.stopPropagation();
        return false; 
      }
    }, true); // Use capture phase
    
    window.addEventListener('unhandledrejection', function(e){
      const r = e && e.reason; 
      const msg = (r && (r.message || String(r))) || '';
      if (typeof msg === 'string' && (msg.includes('getEnabledChains') || msg.includes('isDefaultWallet') || msg.includes('Could not establish connection') || msg.includes('Internal JSON-RPC error') || msg.includes('Receiving end does not exist') || msg.includes('Extension context invalidated'))) { 
        e.preventDefault(); 
        e.stopPropagation();
        return false; 
      }
    }, true); // Use capture phase
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
  <!-- Removed missing assets to avoid 404s -->
  <!-- <link rel="stylesheet" href="css/style.css?v=1.1"> -->
  <!-- <link rel="stylesheet" href="css/mobile-responsive.css"> -->
  <!-- <link rel="stylesheet" href="css/modern-theme.css"> -->
  <!-- <script src="js/mobile-optimizer.js"></script> -->
  <style>
    body {
      background: linear-gradient(135deg, #0a0f1c, #1a1f2e);
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      font-family: 'Noto Sans Arabic', sans-serif;
    }
    .main-container {
      max-width: 600px;
      margin: 0 auto;
      background: #1a1f2e;
      border-radius: 15px;
      padding: 1rem;
      border: 1px solid #00ff88;
      margin-top: 4rem;
    }
    
    .register-form {
      background: linear-gradient(135deg, #232946 80%, #181c2a 100%) !important;
      color: #fff !important;
      border-radius: 16px;
      box-shadow: 0 8px 32px #00000033, 0 1.5px 6px #00ff8840;
      padding: 12px 10px 10px 10px;
    }
    
    /* Back Button Styles */
    .back-btn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      color: #0a0f1c;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(167, 134, 255, 0.3);
      z-index: 1000;
    }
    
    .back-btn:hover {
      background: linear-gradient(135deg, #00ff88, #a786ff);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(167, 134, 255, 0.4);
    }
    .register-form label,
    .register-form-title {
      color: #a786ff !important;
    }
    .register-form input,
    .register-form-input {
      background: #232946 !important;
      color: #fff !important;
      border: 1px solid #444;
    }
    .register-form input:focus {
      border-color: #00ff88;
      background: #232946;
      color: #fff;
    }
    .info-box {
      background: rgba(28,28,40,0.97) !important;
      color: #fff !important;
      border: 1px solid #444;
      box-shadow: 0 2px 8px #00ff8840;
    }
    /* Tab buttons - separate from main register button */
    .tab-btn {
      background: transparent;
      color: #a786ff;
      font-weight: bold;
      border-radius: 6px;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    
    
    /* Main register button */
    .register-btn, .buy-btn {
      background: linear-gradient(90deg,#00ff88,#00cc66) !important;
      color: #232946 !important;
      font-weight: bold;
      border-radius: 10px;
      font-size: 1.13rem;
      box-shadow: 0 2px 8px rgba(0, 255, 136, 0.3);
    }
    .register-btn:active, .buy-btn:active {
      background: linear-gradient(90deg,#00cc66,#00ff88) !important;
    }
    .register-form-status {
      color: #fff !important;
    }
    .form-group {
       margin-bottom: 4px;
    }
    .form-group label {
       margin-bottom: 1px;
       font-size: 0.7rem;
    }
    .register-form-input {
       padding: 2px 4px;
       font-size: 0.45rem;
       word-break: break-all;
       line-height: 1.0;
       font-family: monospace;
       font-style: italic;
    }
    
    /* Index Input - Full Width */
    .index-input {
      width: 100%;
      margin-bottom: 4px;
      padding: 10px 12px;
      font-size: 1rem;
      font-weight: bold;
    }
    
    .apply-btn {
      width: auto;
      padding: 3px 6px;
      font-size: 0.6rem;
      margin-bottom: 3px;
    }
    .avatar-row {
       margin-bottom: 3px;
    }
    .avatar-choice {
       font-size: 1rem;
       padding: 1px;
     }
     .register-form {
       padding: 12px 8px 8px 8px;
     }
     .register-form-title {
       margin-bottom: 4px;
       font-size: 1rem;
    }
    
    /* Register Status Styles */
    .register-form-status {
      margin-top: 1rem;
      padding: 0.8rem;
      border-radius: 8px;
      font-size: 0.9rem;
      text-align: center;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    
    .register-form-status.success {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 0.5px solid rgba(0, 255, 136, 0.3);
    }
    
    .register-form-status.error {
      background: rgba(255, 68, 68, 0.1);
      color: #ff4444;
      border: 0.5px solid rgba(255, 68, 68, 0.3);
    }
    
    .register-form-status.loading {
      background: rgba(167, 134, 255, 0.1);
      color: #a786ff;
      border: 0.5px solid rgba(167, 134, 255, 0.3);
    }
    
    /* Address Input Group Styles */
    .address-input-group {
      display: flex;
      gap: 0.3rem;
      margin-bottom: 0.3rem;
      align-items: center;
    }
    
    .address-input-group input {
      flex: 1;
      font-size: 0.7rem;
      padding: 0.4rem 0.5rem;
    }
    
    .address-input-group .apply-btn {
      padding: 0.3rem 0.5rem;
      font-size: 0.55rem;
      white-space: nowrap;
      min-width: 40px;
    }
    
    .address-field {
      font-size: 0.35rem;
      padding: 0.2rem 0.3rem;
      background: rgba(35, 41, 70, 0.8) !important;
      border: 0.5px solid #555 !important;
      color: #ccc !important;
      word-break: break-all;
      line-height: 1.0;
      font-family: monospace;
      font-style: italic;
    }
    
    .input-with-button {
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    .input-with-button input {
      flex: 0 0 83.33%;
      padding-right: 0.3rem;
    }
    
    .paste-btn-inside {
      flex: 0 0 16.67%;
      background: rgba(52, 152, 219, 0.8);
      border: none;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
      font-size: 0.6rem;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 0.2rem;
    }
    
    .paste-btn-inside:hover {
      background: rgba(52, 152, 219, 1);
      transform: scale(1.05);
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .address-input-group {
        gap: 0.2rem;
        margin-bottom: 0.2rem;
      }
      
      .address-input-group input {
        flex: 0 0 83.33%;
        font-size: 0.65rem;
        padding: 0.3rem 0.4rem;
      }
      
      .address-input-group .apply-btn {
        flex: 0 0 16.67%;
        padding: 0.25rem 0.4rem;
        font-size: 0.5rem;
        min-width: auto;
        width: 100%;
      }
      
      /* Upper index Apply button - 1/6 of screen width */
      .input-with-button input {
        flex: 0 0 83.33%;
        padding-right: 0.2rem;
        font-size: 0.45rem;
        word-break: break-all;
        line-height: 1.0;
        font-family: monospace;
        font-style: italic;
      }
      
      .input-with-button .paste-btn-inside {
        flex: 0 0 16.67%;
        font-size: 0.55rem;
        padding: 0.15rem 0.3rem;
        margin-left: 0.1rem;
      }
      
      .address-field {
        font-size: 0.3rem;
        padding: 0.15rem 0.25rem;
        word-break: break-all;
        line-height: 0.9;
        font-family: monospace;
        font-style: italic;
      }
      
      .input-with-button input {
        flex: 0 0 83.33%;
        padding-right: 0.2rem;
        font-size: 0.65rem;
        font-family: 'Fira Mono', monospace;
        letter-spacing: 0.3px;
      }
      
      .paste-btn-inside {
        flex: 0 0 16.67%;
        font-size: 0.55rem;
        padding: 0.15rem 0.3rem;
        margin-left: 0.1rem;
        min-width: 50px;
      }
      
      /* Mobile-specific improvements for new user field */
      #new-user-address {
        font-family: 'Fira Mono', monospace !important;
        letter-spacing: 0.5px !important;
        font-size: 0.75rem !important;
        padding: 12px 8px !important;
        line-height: 1.3 !important;
        width: 100% !important;
        box-sizing: border-box !important;
      }
      
      #new-user-address::placeholder {
        font-family: 'Fira Mono', monospace;
        letter-spacing: 0.3px;
        opacity: 0.7;
        font-size: 0.7rem;
      }
      
      /* Mobile paste button */
      #paste-new-user-btn {
        font-size: 0.7rem !important;
        padding: 6px 10px !important;
        margin-bottom: 6px !important;
      }
    }
  /* Modern theme override */
  :root{
    --bg: #0b0f17; --card:#0f1420; --elev:#121a2a; --border:#22304a; --accent:#5da0ff; --accent-2:#33d69f; --text:#e6eaf0; --muted:#aab6d3;
  }
  body{ background: var(--bg); color: var(--text); padding:16px; }
  .main-container{ max-width:560px; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
  /* Two-pane responsive layout for Buy + Register */
  .two-pane{ display:grid; gap:12px; }
  @media(min-width:768px){
    .main-container{ max-width:1100px; }
    .two-pane{ grid-template-columns: 1fr 1fr; align-items:start; }
  }
  .section-title{ display:flex; align-items:center; gap:8px; font-weight:800; color:#cfe3ff; margin-bottom:8px; }
  .step-badge{ background:rgba(0,255,136,0.2); color:#00ff88; border:1px solid rgba(0,255,136,0.35); padding:4px 8px; border-radius:999px; font-size:.85rem; }
  .register-form{ background:var(--elev)!important; border:1px solid var(--border); border-radius:14px; padding:16px 14px; }
  .register-form-title, .register-form label{ color:#cfe3ff!important; font-weight:600; }
  .form-group{ margin-bottom:10px; }
  .register-form-input, .register-form input{ background:#0f1420!important; color:var(--text)!important; border:1px solid var(--border); border-radius:12px; padding:12px; font-size:1rem; box-sizing:border-box; }
  .register-form input:focus{ border-color:var(--accent); outline:none; box-shadow:0 0 0 3px rgba(93,160,255,.15); }
  /* Compact layout for index-address rows */
  .index-address-row{ gap: 6px; }
  .index-column{ min-width: 0; }
  .index-column > input{ font-size: 0.9rem; padding: 8px; }
  .index-column > button{ font-size: 0.7rem; padding: 4px 6px; }
  .address-column > input{ font-size: 0.9rem; padding: 8px; }
  .index-input{ height:48px; font-size:1.05rem; }
  .address-input-group{ gap:8px; }
  .address-input-group input{ height:48px; font-size:1.05rem; }
  .address-field{ background:#0f1420!important; border:1px solid var(--border)!important; color:#cfd7ea!important; height:48px; font-size:1.05rem; padding:12px; border-radius:12px; line-height:1.2; }
  
  /* New user address field - show full address */
  #new-user-address {
    font-family: 'Fira Mono', monospace !important;
    letter-spacing: 0.5px !important;
    font-size: 0.85rem !important;
    padding: 12px !important;
    line-height: 1.3 !important;
    background: #0f1420 !important;
    border: 1px solid var(--border) !important;
    color: #cfd7ea !important;
    border-radius: 12px !important;
    width: 100% !important;
    box-sizing: border-box !important;
  }
  
  #new-user-address::placeholder {
    font-family: 'Fira Mono', monospace;
    letter-spacing: 0.3px;
    opacity: 0.7;
    font-size: 0.8rem;
  }
  
  /* Paste button for new user address */
  #paste-new-user-btn {
    background: rgba(0, 255, 136, 0.2) !important;
    color: #00ff88 !important;
    border: 1px solid rgba(0, 255, 136, 0.4) !important;
    border-radius: 8px !important;
    font-weight: 600 !important;
    transition: all 0.3s ease !important;
    cursor: pointer !important;
  }
  
  #paste-new-user-btn:hover {
    background: rgba(0, 255, 136, 0.3) !important;
    border-color: rgba(0, 255, 136, 0.6) !important;
    transform: translateY(-1px) !important;
  }
  
  #paste-new-user-btn:active {
    transform: translateY(0) !important;
  }
  .tab-btn{ background:#0f1420; color:#cfe3ff; border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-weight:600; }
  /* Ensure high-contrast label for Normal Registration */
  .register-btn, .buy-btn{ background:linear-gradient(135deg, #2f9950, #2b8a3e)!important; color:var(--text)!important; border:1px solid #3aa654; padding:12px; border-radius:12px; font-weight:700; font-size:1.05rem; }
  .register-btn:hover, .buy-btn:hover{ filter:brightness(1.05); }
  .apply-btn, .paste-btn-inside{ background:#1a2335; color:#cfe3ff; border:1px solid var(--border); border-radius:12px; padding:14px 16px; font-size:1.05rem; min-width: 88px; }
  .register-form-status{ border-radius:12px; }
  .register-form-status.success{ background:rgba(46,204,113,.08); color:#2ecc71; border:1px solid rgba(46,204,113,.25); }
  .register-form-status.error{ background:rgba(231,76,60,.08); color:#e74c3c; border:1px solid rgba(231,76,60,.25); }
  .register-form-status.loading{ background:rgba(93,160,255,.08); color:#5da0ff; border:1px solid rgba(93,160,255,.25); }
  /* Mobile Responsive Styles - Comprehensive */
  @media (max-width: 768px) {
    body {
      padding: 12px !important;
    }
    
    .back-btn {
      position: relative !important;
      top: auto !important;
      left: auto !important;
      margin-bottom: 12px;
      width: auto;
      display: inline-block;
      font-size: 0.9rem;
      padding: 8px 14px;
    }
    
    .main-container {
      max-width: 100% !important;
      border-radius: 12px;
      padding: 12px;
    }
    
    .two-pane {
      grid-template-columns: 1fr !important;
      gap: 16px;
    }
    
    .section-title {
      font-size: 0.95rem;
      margin-bottom: 10px;
    }
    
    .step-badge {
      font-size: 0.75rem;
      padding: 3px 6px;
    }
    
    /* Buy Section Mobile */
    #buy-section {
      padding: 12px !important;
      margin: 8px 0 !important;
    }
    
    #buy-section .section-title {
      font-size: 0.9rem;
    }
    
    /* Quick Swap Section Mobile */
    #buy-section > div:last-child {
      padding: 10px !important;
      margin-top: 12px !important;
    }
    
    #buy-section > div:last-child > div:first-child {
      font-size: 0.8rem !important;
      margin-bottom: 10px !important;
    }
    
    #quick-swap-dai-amount {
      font-size: 0.95rem !important;
      padding: 10px !important;
    }
    
    #quick-swap-btn {
      font-size: 0.85rem !important;
      padding: 10px !important;
      width: 100% !important;
    }
    
    #quick-swap-status {
      font-size: 0.75rem !important;
      word-wrap: break-word;
    }
    
    /* Register Form Mobile */
    .register-form {
      padding: 12px 10px !important;
      border-radius: 12px;
    }
    
    .form-group {
      margin-bottom: 12px;
    }
    
    .form-group label {
      font-size: 0.9rem;
      margin-bottom: 6px;
      display: block;
    }
    
    .register-form-input,
    .register-form input,
    .address-input-group input,
    .address-field {
      height: 46px;
      font-size: 0.95rem;
      padding: 10px;
    }
    
    /* Index-Address Row Mobile */
    .index-address-row {
      flex-direction: column !important;
      gap: 8px !important;
    }
    
    .index-column {
      flex: 1 1 100% !important;
      width: 100% !important;
    }
    
    .address-column {
      flex: 1 1 100% !important;
      width: 100% !important;
    }
    
    .index-column > input {
      width: 100% !important;
      font-size: 0.9rem !important;
    }
    
    .index-column > button {
      width: 100% !important;
      margin-top: 4px !important;
      font-size: 0.85rem !important;
      padding: 10px !important;
    }
    
    .address-column > input {
      width: 100% !important;
      font-size: 0.9rem !important;
    }
    
    /* Buttons Mobile */
    .register-btn,
    .buy-btn {
      font-size: 0.95rem !important;
      padding: 12px !important;
      width: 100% !important;
      margin-top: 8px;
    }
    
    .apply-btn,
    .paste-btn-inside,
    #upper-apply-index-btn {
      font-size: 0.9rem !important;
      padding: 10px 12px !important;
      width: 100%;
    }
    
    #paste-new-user-btn {
      width: 100% !important;
      min-height: 46px !important;
      font-size: 0.85rem !important;
    }
    
    /* Status Messages Mobile */
    .register-form-status {
      font-size: 0.85rem !important;
      padding: 10px !important;
      margin-top: 8px;
      word-wrap: break-word;
    }
    
    /* Stats row mobile */
    #buy-section > div:first-of-type {
      flex-direction: column !important;
      gap: 6px !important;
    }
    
    #buy-section > div:first-of-type > div {
      width: 100% !important;
      text-align: center;
      font-size: 0.75rem !important;
    }
  }
  
  /* Extra Small Mobile (up to 480px) */
  @media (max-width: 480px) {
    body {
      padding: 8px !important;
    }
    
    .back-btn {
      font-size: 0.85rem;
      padding: 6px 12px;
      margin-bottom: 10px;
    }
    
    .main-container {
      padding: 10px !important;
    }
    
    #buy-section {
      padding: 10px !important;
    }
    
    .register-form {
      padding: 10px 8px !important;
    }
    
    .form-group {
      margin-bottom: 10px;
    }
    
    .register-form-input,
    .register-form input {
      font-size: 0.9rem !important;
      padding: 8px !important;
      height: 44px !important;
    }
    
    .section-title {
      font-size: 0.85rem;
    }
    
    .step-badge {
      font-size: 0.7rem;
      padding: 2px 5px;
    }
    
    .register-btn,
    .buy-btn {
      font-size: 0.9rem !important;
      padding: 10px !important;
    }
    
    /* Compact Quick Swap */
    #quick-swap-dai-amount {
      font-size: 0.9rem !important;
      padding: 8px !important;
    }
    
    #quick-swap-btn {
      font-size: 0.8rem !important;
      padding: 8px !important;
    }
  }
  
  </style>
</head>
<body>
  
  <!-- Back Button -->
  <a href="index.html" class="back-btn">← Back</a>

  <!-- Main Content -->
  <div class="main-container">
    <div class="two-pane">
        
        <!-- Buy Section -->
        <div class="info-box" id="buy-section" style="margin:8px 0; padding:8px; border-radius:10px; border:1px solid rgba(0,255,136,0.3); background: linear-gradient(135deg, rgba(0,255,136,0.05), rgba(167,134,255,0.05)); box-shadow: 0 4px 16px rgba(0,0,0,0.2), inset 0 0 0 1px rgba(255,255,255,0.03);">
          <div class="section-title" style="text-align: right;">Buy IAM</div>
          
          

          <!-- Quick Swap: DAI to IAM -->
          <div style="background: rgba(93, 160, 255, 0.1); border: 1px solid rgba(93, 160, 255, 0.3); border-radius: 10px; padding: 12px; margin-top: 12px;">
            <div style="font-size: 0.85rem; color: #cfe3ff; margin-bottom: 10px; font-weight: 600;">
              💱 Quick Swap: DAI → IAM
            </div>
            
            <!-- DAI Amount Input -->
            <div style="margin-bottom: 8px;">
              <label style="display: block; font-size: 0.75rem; color: #cfe3ff; margin-bottom: 4px;">DAI Amount</label>
              <input type="number" id="quick-swap-dai-amount" placeholder="Your dollar amount (USD)" step="0.01" min="0" style="width: 100%; background: #0f1420; border: 1px solid var(--border); color: #cfd7ea; border-radius: 8px; padding: 10px; font-size: 1rem; box-sizing: border-box;">
            </div>
            
            <!-- Stats row (Your IAM, Your DAI) -->
            <div style="display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; font-size:0.78rem;">
              <div style="background: rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.08); padding:4px 8px; border-radius:8px; color:#cfe3ff;">
                Your IAM: <b id="buy-current-iam" style="color:#a786ff;">...</b>
              </div>
              <div style="background: rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.08); padding:4px 8px; border-radius:8px; color:#cfe3ff;">
                Your DAI: <b id="quick-swap-dai-balance" style="color:#5da0ff;">...</b>
              </div>
            </div>
            
            
            
            <!-- Swap Button -->
            <button type="button" id="quick-swap-btn" class="buy-btn" style="width: 100%; padding: 10px; font-size: 0.9rem; white-space: nowrap;">
              🔄 Swap DAI to IAM
            </button>
            
            <!-- Status Message -->
            <div id="quick-swap-status" style="margin-top: 8px; font-size: 0.8rem; min-height: 20px;"></div>
          </div>
        </div>

        <!-- Register Section -->
        <form class="register-form" id="register-section" autocomplete="off">
          <div class="section-title" style="text-align: right;">Register</div>
               <!-- Registration tabs -->
      <div class="register-form-status warning" id="register-suggestion" style="display:none;"></div>
      
      
      
      <!-- Referrer Address (Number or Address) -->
      <div class="form-group">
        <label for="referrer-address-display">Referrer (Address or Index)</label>
        <input type="text" id="referrer-address-display" class="register-form-input address-field" placeholder="Enter address or index (e.g., 0x... or 123)" autocomplete="off" style="width: 100%;">
        <div id="referrer-validation-status" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem;"></div>
      </div>

      <!-- Upper Address (Number or Address) -->
      <div class="form-group">
        <label for="upper-address" id="upper-label">Upper (Address or Index)</label>
        <input type="text" id="upper-address" class="register-form-input address-field" placeholder="Enter address or index (e.g., 0x... or 123)" autocomplete="off" value="root" style="width: 100%;">
        <div id="upper-validation-status" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem;"></div>
      </div>

      <!-- New User Address -->
      <div class="form-group">
        <label for="new-user-address">New User Address</label>
        <div class="index-address-row" style="display: flex; gap: 8px; align-items: stretch;">
          <div class="index-column" style="flex: 0 0 25%;">
            <button type="button" id="paste-new-user-btn" class="paste-btn-inside" style="width: 100%; padding: 8px 12px; font-size: 0.8rem; height: 100%; min-height: 46px;">📋 Paste</button>
          </div>
          <div class="address-column" style="flex: 0 0 75%;">
            <input type="text" id="new-user-address" class="register-form-input" placeholder="0x..." autocomplete="off" style="font-family: 'Fira Mono', monospace; letter-spacing: 0.5px; width: 100%;">
          </div>
        </div>
        <div id="new-user-address-info" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); color: #00ff88;"></div>
      </div>
       
                       <button class="register-btn buy-btn" id="register-btn" type="button" style="width:100%;margin-top:6px;">Register</button>
      
      <script>
         // Function to display general messages
     function showMessageBox(message, type = 'info') {
         // Remove previous message box if exists
         const existingBox = document.getElementById('message-box');
         if (existingBox) {
             existingBox.remove();
         }
         
         // Create new message box
         const messageBox = document.createElement('div');
         messageBox.id = 'message-box';
         messageBox.style.cssText = `
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: ${type === 'error' ? 'rgba(255, 0, 0, 0.95)' : type === 'success' ? 'rgba(0, 255, 136, 0.95)' : 'rgba(167, 134, 255, 0.95)'};
             color: white;
             padding: 20px 30px;
             border-radius: 12px;
             box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
             z-index: 10000;
             max-width: 400px;
             text-align: center;
             font-size: 14px;
             line-height: 1.5;
             backdrop-filter: blur(10px);
             border: 1px solid ${type === 'error' ? 'rgba(255, 0, 0, 0.3)' : type === 'success' ? 'rgba(0, 255, 136, 0.3)' : 'rgba(167, 134, 255, 0.3)'};
         `;
         
         // Icon based on message type
         const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
         
         messageBox.innerHTML = `
             <div style="margin-bottom: 10px; font-size: 24px;">${icon}</div>
             <div style="margin-bottom: 15px;">${message}</div>
             <button onclick="this.parentElement.remove()" style="
                 background: rgba(255, 255, 255, 0.2);
                 border: 1px solid rgba(255, 255, 255, 0.3);
                 color: white;
                 padding: 8px 20px;
                 border-radius: 6px;
                 cursor: pointer;
                 font-size: 13px;
                 transition: all 0.3s ease;
             " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                 Close
             </button>
         `;
         
         document.body.appendChild(messageBox);
         
         // Auto remove after 5 seconds
         setTimeout(() => {
             if (messageBox.parentElement) {
                 messageBox.remove();
             }
         }, 5000);
     }

     // Function to display message box for index checking (without exit button)
     function showIndexCheckMessage(message, type = 'info') {
         // Remove previous message box if exists
         const existingBox = document.getElementById('index-check-message');
         if (existingBox) {
             existingBox.remove();
         }
         
         // Determine color and icon based on type
         let bgColor, borderColor, icon;
         if (type === 'error') {
             bgColor = 'rgba(255, 0, 0, 0.95)';
             borderColor = 'rgba(255, 0, 0, 0.3)';
             icon = '❌';
         } else if (type === 'success') {
             bgColor = 'rgba(0, 255, 136, 0.95)';
             borderColor = 'rgba(0, 255, 136, 0.3)';
             icon = '✅';
         } else if (type === 'warning') {
             bgColor = 'rgba(255, 165, 0, 0.95)';
             borderColor = 'rgba(255, 165, 0, 0.3)';
             icon = '⚠️';
         } else {
             bgColor = 'rgba(0, 123, 255, 0.95)';
             borderColor = 'rgba(0, 123, 255, 0.3)';
             icon = 'ℹ️';
         }
         
         // Create new message box
         const messageBox = document.createElement('div');
         messageBox.id = 'index-check-message';
         messageBox.style.cssText = `
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: ${bgColor};
             color: white;
             padding: 25px 30px;
             border-radius: 16px;
             box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
             z-index: 10000;
             max-width: 90vw;
             width: 350px;
             text-align: center;
             font-size: 16px;
             line-height: 1.6;
             backdrop-filter: blur(15px);
             border: 2px solid ${borderColor};
             font-weight: 500;
         `;
         
         messageBox.innerHTML = `
             <div style="margin-bottom: 15px; font-size: 32px;">${icon}</div>
             <div style="margin-bottom: 20px; font-size: 18px; font-weight: bold;">Index Check Result</div>
             <div style="margin-bottom: 20px; font-size: 15px; line-height: 1.5;">${message}</div>
         `;
         
         document.body.appendChild(messageBox);
         
         // Auto remove after 4 seconds
         setTimeout(() => {
             if (messageBox.parentElement) {
                 messageBox.style.animation = 'fadeOut 0.5s ease';
                 setTimeout(() => messageBox.remove(), 500);
             }
         }, 4000);
     }


    // Function to show guide for buying IAM (updated to redirect to buy section instead of swap page)
    function showBuyIamGuide(shortageAmount = '') {
        console.log('📱 Showing buy IAM guide with shortage:', shortageAmount);
        const guideBox = document.createElement('div');
        guideBox.id = 'buy-iam-guide';
        guideBox.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(93, 160, 255, 0.95);
            color: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            max-width: 90vw;
            width: 400px;
            text-align: center;
            font-size: 16px;
            line-height: 1.6;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(93, 160, 255, 0.5);
            font-weight: 500;
        `;
        
        const shortageText = shortageAmount ? `You need ${shortageAmount} more IAM tokens. ` : '';
        
        guideBox.innerHTML = `
            <div style="margin-bottom: 20px; font-size: 48px;">💡</div>
            <div style="margin-bottom: 20px; font-size: 20px; font-weight: bold;">Insufficient IAM Balance</div>
            <div style="margin-bottom: 25px; font-size: 15px; line-height: 1.6;">
                ${shortageText}You can easily buy IAM tokens by swapping DAI in the Buy section above.
            </div>
            <div style="margin-bottom: 25px; font-size: 14px; background: rgba(255,255,255,0.15); padding: 15px; border-radius: 10px; line-height: 1.6;">
                <strong>How to buy IAM:</strong><br>
                1. Scroll to Buy IAM section above<br>
                2. Enter DAI amount<br>
                3. Click Swap DAI to IAM<br>
                4. Return here to register
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="goToBuySection('${shortageAmount}')" style="
                    background: rgba(0, 255, 136, 0.9);
                    border: 2px solid rgba(0, 255, 136, 0.5);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                " onmouseover="this.style.background='rgba(0, 255, 136, 1)'" onmouseout="this.style.background='rgba(0, 255, 136, 0.9)'">
                    ➤ Go to Buy Section
                </button>
                <button onclick="this.closest('#buy-iam-guide').remove()" style="
                    background: rgba(255, 255, 255, 0.2);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                    Close
                </button>
            </div>
        `;
        
        document.body.appendChild(guideBox);
    }
    
    // Function to scroll to buy section and auto-fill amount
    function goToBuySection(shortageAmount = '') {
        console.log('📍 Navigating to Buy Section with shortage:', shortageAmount);
        try {
            // Close guide box
            const guideBox = document.getElementById('buy-iam-guide');
            if (guideBox) {
                guideBox.remove();
            }
            
            // Find buy section element
            const buySection = document.getElementById('buy-section');
            if (!buySection) {
                console.warn('Buy section not found');
                return;
            }
            
            // Scroll to buy section smoothly
            buySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Highlight the buy section briefly
            buySection.style.transition = 'box-shadow 0.3s ease';
            buySection.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.6)';
            setTimeout(() => {
                buySection.style.boxShadow = '';
            }, 2000);
            
            // Auto-fill DAI amount if shortage amount is provided
            if (shortageAmount && parseFloat(shortageAmount) > 0) {
                setTimeout(() => {
                    const quickSwapInput = document.getElementById('quick-swap-dai-amount');
                    if (quickSwapInput) {
                        // Calculate DAI needed from IAM shortage
                        try {
                            let contract = window.contractConfig && window.contractConfig.contract;
                            if (contract && typeof contract.getTokenPrice === 'function') {
                                contract.getTokenPrice().then(price => {
                                    const tokenPrice = Number(ethers.formatUnits(price, 18)) || 1;
                                    const daiNeeded = parseFloat(shortageAmount) * tokenPrice * 1.1; // 10% buffer
                                    quickSwapInput.value = daiNeeded.toFixed(4);
                                    quickSwapInput.focus();
                                    // Trigger input event to update estimates
                                    quickSwapInput.dispatchEvent(new Event('input', { bubbles: true }));
                                }).catch(() => {
                                    // Fallback if price fetch fails
                                    const daiNeeded = parseFloat(shortageAmount) * 1.1;
                                    quickSwapInput.value = daiNeeded.toFixed(4);
                                    quickSwapInput.focus();
                                });
                            } else {
                                // Fallback: assume 1:1 ratio
                                const daiNeeded = parseFloat(shortageAmount) * 1.1;
                                quickSwapInput.value = daiNeeded.toFixed(4);
                                quickSwapInput.focus();
                            }
                        } catch(e) {
                            console.error('Error calculating DAI amount:', e);
                            // Fallback: assume 1:1 ratio
                            const daiNeeded = parseFloat(shortageAmount) * 1.1;
                            if (quickSwapInput) {
                                quickSwapInput.value = daiNeeded.toFixed(4);
                                quickSwapInput.focus();
                            }
                        }
                    }
                }, 500); // Wait for scroll to complete
            }
        } catch(e) {
            console.error('Error navigating to buy section:', e);
        }
    }
    
    // Keep goToSwapPage for backward compatibility but redirect to buy section
    function goToSwapPage(shortageAmount = '') {
        goToBuySection(shortageAmount);
    }
    
    // Make functions globally accessible
    try { window.showBuyIamGuide = showBuyIamGuide; } catch(_) {}
    try { window.goToSwapPage = goToSwapPage; } catch(_) {}
    try { window.goToBuySection = goToBuySection; } catch(_) {}

    // Function to display temporary messages (for validation)
    function showTempMessage(message, type = 'info', duration = 3000) {
        const tempBox = document.createElement('div');
        tempBox.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'error' ? 'rgba(255, 0, 0, 0.9)' : type === 'success' ? 'rgba(0, 255, 136, 0.9)' : 'rgba(167, 134, 255, 0.9)'};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            z-index: 9999;
            font-size: 13px;
            max-width: 300px;
            backdrop-filter: blur(8px);
            border: 1px solid ${type === 'error' ? 'rgba(255, 0, 0, 0.3)' : type === 'success' ? 'rgba(0, 255, 136, 0.3)' : 'rgba(167, 134, 255, 0.3)'};
            animation: slideIn 0.3s ease;
        `;
        
        const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
        tempBox.innerHTML = `${icon} ${message}`;
        
        document.body.appendChild(tempBox);
        
        setTimeout(() => {
            if (tempBox.parentElement) {
                tempBox.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => tempBox.remove(), 300);
            }
        }, duration);
    }

    // Add CSS animations
    if (!document.getElementById('message-box-styles')) {
        const style = document.createElement('style');
        style.id = 'message-box-styles';
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                to { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            }
        `;
        document.head.appendChild(style);
    }

         // Define input variables before any use
         let newUserInput, referrerDisplay, referrerIndexInput, upperInput, upperIndexInput, refInput, indexInput;
         
          // Function to handle referral parameters from URL
          async function handleReferralParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const refParam = urlParams.get('ref') || urlParams.get('referrer');
            const upperIndex = urlParams.get('upper');
            const upperAddress = urlParams.get('upperAddr');
            const emptyIndex = urlParams.get('emptyIndex');
            const position = urlParams.get('position');
            
            console.log('🔗 Referral parameters:', { ref: refParam, upperIndex, upperAddress, emptyIndex, position });
            
            // Handle referrer from URL (?ref=address or ?ref=number)
            if (refParam) {
              // Check if it's an address
              if (/^0x[a-fA-F0-9]{40}$/.test(refParam)) {
                // It's an address - fill directly
                if (referrerDisplay) {
                  referrerDisplay.value = refParam;
                  referrerDisplay.setAttribute('data-full-address', refParam);
                  updateAddressDisplay(referrerDisplay);
                  await checkAddressValidity(referrerDisplay, 'referrer');
                }
                // If no explicit upper provided, set upper = referrer as well
                if (!upperIndex && !upperAddress && upperInput) {
                  upperInput.value = refParam;
                  upperInput.setAttribute('data-full-address', refParam);
                  updateAddressDisplay(upperInput);
                  setTimeout(async () => { await checkAddressValidity(upperInput, 'upper'); }, 200);
                }
              } else if (/^\d+$/.test(refParam)) {
                // It's a number - convert to address
                await applyIndexToAddress(refParam, referrerDisplay, 'referrer');
                // If no explicit upper provided, set upper = referrer number as well
                if (!upperIndex && !upperAddress) {
                  setTimeout(async () => { await applyIndexToAddress(refParam, upperInput, 'upper'); }, 200);
                }
              }
            }
            
            // Auto-fill upper information if provided
            if (upperIndex) {
              // Trigger conversion and validation
              setTimeout(async () => {
                await applyIndexToAddress(upperIndex, upperInput, 'upper');
              }, 700);
            }
            
            if (upperAddress) {
              if (upperInput) {
                upperInput.value = upperAddress;
                upperInput.setAttribute('data-full-address', upperAddress);
                updateAddressDisplay(upperInput);
                // Trigger validation
                setTimeout(async () => {
                  await checkAddressValidity(upperInput, 'upper');
                }, 700);
              }
            }
            
            // Show success message if parameters were processed
            if (refParam || upperIndex || upperAddress) {
              setTimeout(() => {
                if (refParam) {
                  const refStatusDiv = document.getElementById('referrer-validation-status');
                  if (refStatusDiv) {
                    refStatusDiv.style.display = 'block';
                    refStatusDiv.className = 'register-form-status success';
                    refStatusDiv.textContent = '✅ Referrer loaded from referral link';
                  }
                }
                if (upperIndex || upperAddress) {
                  const statusDiv = document.getElementById('upper-validation-status');
                  if (statusDiv) {
                    statusDiv.style.display = 'block';
                    statusDiv.className = 'register-form-status success';
                    statusDiv.textContent = `✅ Upper information loaded from link successfully! (Slot: ${emptyIndex || 'N/A'}, Position: ${position || 'N/A'})`;
                  }
                }
              }, 1000);
            }
          }
         
         document.addEventListener('DOMContentLoaded', function() {
           newUserInput = document.getElementById('new-user-address');
           referrerDisplay = document.getElementById('referrer-address-display');
           referrerIndexInput = null; // Index field removed - use address field directly
           upperInput = document.getElementById('upper-address');
           upperIndexInput = null; // Index field removed - use address field directly
           refInput = document.getElementById('referrer-address');
           indexInput = null; // Index field removed
           
           // Handle URL parameters for referral links
           handleReferralParameters().catch(err => console.error('Error handling referral parameters:', err));
           
           // Initialize global variables
           window.upperIndexInput = null; // Index field removed
           window.refInput = refInput;
           window.upperInput = upperInput;
           window.newUserInput = newUserInput;
           window.referrerDisplay = referrerDisplay;
           window.referrerIndexInput = null; // Index field removed
           
           // Set up all event listeners here
           setupEventListeners();

           // Buy button → scroll to buy section with shortage prefilled
           const goSwap = document.getElementById('go-to-swap-btn');
           if (goSwap) {
             goSwap.addEventListener('click', function(){
               try {
                 const shortageText = (document.getElementById('iam-shortage')?.textContent || '0').trim();
                 const shortage = parseFloatSafe(shortageText);
                 const shortageStr = isFinite(shortage) && shortage > 0 ? shortage.toFixed(2) : '';
                 // Scroll to buy section with prefilled amount
                 if (typeof window.goToBuySection === 'function') {
                   window.goToBuySection(shortageStr);
                 } else {
                   // Fallback: manual scroll
                   const buySection = document.getElementById('buy-section');
                   if (buySection) {
                     buySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                   }
                 }
               } catch(_) {
                 // Fallback: just scroll to buy section
                 const buySection = document.getElementById('buy-section');
                 if (buySection) {
                   buySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                 }
               }
             });
           }

           // Re-check balances on return focus
           window.addEventListener('focus', async () => {
             try {
               await refreshBalancesAndAvailability();
             } catch(_) {}
           });

           // Light polling while buy box visible
           setInterval(async () => {
             try {
               const buyBox = document.getElementById('buy-section');
               if (buyBox && buyBox.style.display !== 'none') {
                 await refreshBalancesAndAvailability();
               }
             } catch(_) {}
           }, 7000);
           
           function setupEventListeners() {
             // Ensure referrerDisplay is available
             if (!referrerDisplay) {
               referrerDisplay = document.getElementById('referrer-address-display');
             }
             
            // Note: Index fields removed - users can type numbers directly into address fields
            // The input event listeners on address fields will handle number-to-address conversion
             
             // Paste button for new user address
             const pasteNewUserBtn = document.getElementById('paste-new-user-btn');
             const newUserInput = document.getElementById('new-user-address');
             
             if (pasteNewUserBtn && newUserInput) {
               pasteNewUserBtn.addEventListener('click', async function() {
                 try {
                   const text = await navigator.clipboard.readText();
                   if (text && text.trim()) {
                     // Clean the pasted text - remove extra spaces and newlines
                     const cleanedText = text.trim().replace(/\s+/g, '');
                     newUserInput.value = cleanedText;
                     
                     // Trigger validation
                     newUserInput.dispatchEvent(new Event('input'));
                     
                     showTempMessage('✅ Address pasted successfully', 'success');
                   } else {
                     showTempMessage('❌ No text found in clipboard', 'error');
                   }
                 } catch (error) {
                   console.error('Paste failed:', error);
                   showTempMessage('❌ Paste failed. Please paste manually.', 'error');
                 }
               });
             }
             
             // Address field event listeners (for manual editing)
             referrerDisplay.addEventListener('change', async function() {
               await checkAddressValidity(referrerDisplay, 'referrer');
               await validateUpperAgainstReferrer();
               await calculatePlacementForNewUser();
             });
            // Debounced resolve when user types a number in referrer address field
            let referrerAddrTimer = null;
            referrerDisplay.addEventListener('input', function() {
              if (referrerAddrTimer) clearTimeout(referrerAddrTimer);
              referrerAddrTimer = setTimeout(async () => {
                const v = (referrerDisplay.value || '').trim();
                if (!v) return;
                if (/^(IAM\d+|\d+)$/.test(v)) {
                  // Resolve number to address
                  await applyIndexToAddress(v, referrerDisplay, 'referrer');
                  await validateUpperAgainstReferrer();
                  await calculatePlacementForNewUser();
                } else if (/^0x[a-fA-F0-9]{40}$/.test(v)) {
                  // It's already an address - validate it
                  referrerDisplay.setAttribute('data-full-address', v);
                  updateAddressDisplay(referrerDisplay);
                  await checkAddressValidity(referrerDisplay, 'referrer');
                  await validateUpperAgainstReferrer();
                  await calculatePlacementForNewUser();
                }
              }, 2000);
            });
             
             // New user address input handler - clean spaces automatically
             if (newUserInput) {
               newUserInput.addEventListener('input', function() {
                 // Remove any spaces, newlines, or extra characters
                 const cleanedValue = this.value.replace(/\s+/g, '');
                 if (this.value !== cleanedValue) {
                   this.value = cleanedValue;
                 }
               });
               
               newUserInput.addEventListener('paste', function(e) {
                 // Allow paste to complete, then clean it
                 setTimeout(() => {
                   const cleanedValue = this.value.replace(/\s+/g, '');
                   if (this.value !== cleanedValue) {
                     this.value = cleanedValue;
                     showTempMessage('✅ Address cleaned automatically', 'success');
                   }
                 }, 10);
               });
             }
             
             
             upperInput.addEventListener('change', async function() {
               await checkAddressValidity(upperInput, 'upper');
               await validateUpperAgainstReferrer();
             });
            // Debounced resolve when user types a number in upper address field
            let upperAddrTimer = null;
            upperInput.addEventListener('input', function() {
              if (upperAddrTimer) clearTimeout(upperAddrTimer);
              upperAddrTimer = setTimeout(async () => {
                const v = (upperInput.value || '').trim();
                if (!v) return;
                if (/^(IAM\d+|\d+)$/.test(v)) {
                  // Resolve number to address
                  await applyIndexToAddress(v, upperInput, 'upper');
                  await validateUpperAgainstReferrer();
                } else if (/^0x[a-fA-F0-9]{40}$/.test(v)) {
                  // It's already an address - validate it
                  upperInput.setAttribute('data-full-address', v);
                  updateAddressDisplay(upperInput);
                  await checkAddressValidity(upperInput, 'upper');
                  await validateUpperAgainstReferrer();
                }
              }, 2000);
            });
           }
           
           
           
          // Note: Index input fields removed - clipboard functionality can be added to address fields if needed
           
           // New user input event listeners
           if (newUserInput) {
             newUserInput.addEventListener('change', async function() {
               await checkNewUserAddress();
             });
             
             newUserInput.addEventListener('input', async function() {
               await checkNewUserAddress();
               await calculatePlacementForNewUser();
             });
             
             newUserInput.addEventListener('paste', async function() {
               setTimeout(async () => {
                 await checkNewUserAddress();
                 await calculatePlacementForNewUser();
               }, 100);
             });
           }
           
           // Index input event listeners
           if (indexInput) {
             const defaultGuide = 'e.g. 123 or IAM123';
             
             indexInput.addEventListener('focus', function() {
               if (this.value === defaultGuide) {
                 this.value = '';
                 this.style.background = '';
                 this.style.color = '';
                 this.style.opacity = '';
               }
             });
             
             indexInput.addEventListener('blur', function() {
               if (this.value.trim() === '') {
                 this.value = defaultGuide;
                 this.style.background = '#f3f3f3';
                 this.style.color = '#888';
                 this.style.opacity = '0.7';
                 if (refInput) {
                   refInput.value = 'root';
                 }
               }
             });
           }
         });
       </script>
      <div class="avatar-row" style="display:none; margin:0;">
        <span class="avatar-choice selected" data-avatar="man">👨‍💼</span>
        <span class="avatar-choice" data-avatar="woman">👩‍💼</span>
        <span class="avatar-choice" data-avatar="student-man">👨‍🎓</span>
        <span class="avatar-choice" data-avatar="student-woman">👩‍🎓</span>
      </div>
      
      <div class="register-form-status" id="status-message"></div>
      
      <!-- Manual retry button for wallet connection issues -->
      <div id="wallet-retry-section" style="display: none; margin-top: 10px; text-align: center;">
        <button id="retry-wallet-btn" class="btn" style="background: linear-gradient(135deg, #a786ff, #00ff88); color: #0a0f1c; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer;">
          🔄 Retry Wallet Connection
        </button>
      </div>
  
      

    </form>
  </div>
  <!-- Web3 and Ethers.js - Load first -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
  
  <!-- Ensure ethers is loaded -->
  <script>
      if (typeof ethers === 'undefined') {
          console.error('❌ Ethers.js not loaded properly');
      } else {
          console.log('✅ Ethers.js loaded:', ethers.version);
      }
  </script>
  
  <script>window.SKIP_META = true;</script>
  <script src="js/config.js"></script>
  <script src="js/auto-wallet-connect.js"></script>
  <script>
    // Fallback helpers to avoid calling non-existent contract functions
    window.safeGetRegPrice = async function(contract){
      try {
        if (contract && typeof contract.getRegPrice === 'function') {
          return await contract.getRegPrice();
        }
      } catch(_) {}
      try {
        if (contract && typeof contract.regPrice === 'function') {
          return await contract.regPrice();
        }
      } catch(_) {}
      try {
        if (contract && typeof contract.registrationPrice === 'function') {
          return await contract.registrationPrice();
        }
      } catch(_) {}
      try {
        if (contract && typeof contract.getRegistrationPrice === 'function') {
          return await contract.getRegistrationPrice();
        }
      } catch(_) {}
      // Default fallback (100 IAM)
      try { return ethers.parseUnits('100', 18); } catch(_) { return null; }
    };

    window.safeGetLeftAddress = async function(contract, parentIndex){
      if (!contract) return null;
      if (typeof contract.getLeftAddress === 'function') {
        try { return await contract.getLeftAddress(parentIndex); } catch(_) {}
      }
      return null; // gracefully fallback
    };
    window.safeGetRightAddress = async function(contract, parentIndex){
      if (!contract) return null;
      if (typeof contract.getRightAddress === 'function') {
        try { return await contract.getRightAddress(parentIndex); } catch(_) {}
      }
      return null; // gracefully fallback
    };
    // Minimal ERC20 ABI for approve/balance
    const MIN_ERC20_ABI = [
      { "constant": false, "inputs": [{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}], "name": "approve", "outputs": [{"name":"","type":"bool"}], "type": "function" },
      { "constant": true, "inputs": [{"name":"owner","type":"address"}], "name": "balanceOf", "outputs": [{"name":"","type":"uint256"}], "type": "function" },
      { "constant": true, "inputs": [], "name": "decimals", "outputs": [{"name":"","type":"uint8"}], "type": "function" }
    ];

    async function getDaiContract(provider){
      const daiAddr = window.DAI_ADDRESS || window.daiAddress || '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063';
      try {
        const signer = await provider.getSigner();
        return new ethers.Contract(daiAddr, MIN_ERC20_ABI, signer);
      } catch(_) { return null; }
    }

    async function updateBuyEstimates(){
      try {
        const helper = document.getElementById('buy-dai-helper');
        const input = document.getElementById('buy-dai-amount');
        const reqEl = document.getElementById('buy-required-iam');
        const curEl = document.getElementById('buy-current-iam');
        const daiBalEl = document.getElementById('buy-dai-balance');
        if (!helper || !input) return;
        const needText = document.getElementById('buy-required-iam')?.textContent || document.getElementById('required-cost-text')?.textContent || '0';
        const iamText = document.getElementById('IAM-balance')?.textContent || '0';
        const needIam = Math.max(0, parseFloatSafe(needText) || 0);
        if (reqEl && isFinite(needIam)) reqEl.textContent = Number(needIam).toFixed(2);
        if (curEl) curEl.textContent = isFinite(parseFloatSafe(iamText)) ? Number(parseFloatSafe(iamText)).toFixed(2) : '...';
        if (needIam <= 0) { input.value = ''; input.placeholder = '0.00'; helper.textContent = 'Balance sufficient'; return; }
        // Get price from contract
        let price = 1;
        try {
          let c = window.contractConfig && window.contractConfig.contract;
          if (!c && typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            c = conn && conn.contract ? conn.contract : c;
          }
          if (c && typeof c.getTokenPrice === 'function') {
            const p = await c.getTokenPrice();
            price = Number(ethers.formatUnits(p, 18)) || 1;
          }
        } catch(_) {}
        // Round up to 4 decimals to avoid underbuy due to precision
        let needDai = needIam * price;
        needDai = Math.ceil(needDai * 10000) / 10000;
        const val = needDai > 0 ? needDai.toFixed(4) : '';
        input.value = val;
        input.placeholder = val || '0.00';
        helper.textContent = `~ ${val || '0.0000'} DAI needed at current price`;
        // Set button label with needed DAI
        const buyBtn = document.getElementById('direct-buy-btn');
        if (buyBtn) buyBtn.textContent = val ? `Buy IAM (~ ${val} DAI)` : 'Buy IAM';

        // Update DAI balance
        try {
          if (daiBalEl && window.ethereum) {
            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            const me = await signer.getAddress();
            const dai = await getDaiContract(provider);
            if (dai && typeof dai.balanceOf === 'function') {
              const bal = await dai.balanceOf(me);
              // attempt decimals; if fails assume 18
              let dec = 18;
              try { dec = await dai.decimals(); } catch(_) {}
              const balNum = Number(ethers.formatUnits(bal, dec));
              daiBalEl.textContent = balNum.toFixed(4);
            }
          }
        } catch(_) {}
      } catch(_) {}
    }

    async function refreshBuyCardBalances(conn){
      try {
        // Get regPrice directly from contract for buy-required-iam
        const reqEl = document.getElementById('buy-required-iam');
        const contract = conn?.contract || (window.contractConfig && window.contractConfig.contract);
        if (reqEl && contract) {
          try {
            let wei = null;
            if (typeof contract.getRegPrice === 'function') {
              wei = await contract.getRegPrice();
            } else if (window.safeGetRegPrice) {
              wei = await window.safeGetRegPrice(contract);
            }
            if (wei !== null && wei !== undefined) {
              const regIAM = Number(ethers.formatUnits(wei, 18)) || 0;
              reqEl.textContent = regIAM > 0 ? regIAM.toFixed(2) : '...';
            }
          } catch(_) {}
        }
        // Get current IAM balance directly from contract
        try {
        const curEl = document.getElementById('buy-current-iam');
          if (curEl && window.ethereum) {
            // Resolve provider, signer and user address
            const provider = conn?.provider || new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            const me = conn?.address || await signer.getAddress();
            // Resolve contract instance
            let contract = conn?.contract || (window.contractConfig && window.contractConfig.contract);
            if (!contract && typeof window.connectWallet === 'function') {
              try { const c = await window.connectWallet(); contract = c && c.contract ? c.contract : contract; } catch(_) {}
            }
            if (contract && typeof contract.balanceOf === 'function') {
              const bal = await contract.balanceOf(me);
              curEl.textContent = Number(ethers.formatUnits(bal, 18)).toFixed(2);
            }
          }
        } catch(_) {}
        // DAI balance
        const daiEl = document.getElementById('buy-dai-balance');
        if (daiEl && window.ethereum) {
          const provider = conn?.provider || new ethers.BrowserProvider(window.ethereum);
          const signer = await provider.getSigner();
          const me = conn?.address || await signer.getAddress();
          const dai = await getDaiContract(provider);
          if (dai && typeof dai.balanceOf === 'function') {
            const bal = await dai.balanceOf(me);
            let dec = 18;
            try { dec = await dai.decimals(); } catch(_) {}
            daiEl.textContent = Number(ethers.formatUnits(bal, dec)).toFixed(4);
          }
        }
        // Ensure DAI input suggestion is computed
        await updateBuyEstimates();
        // Auto-fill Quick Swap DAI field with required amount (no buffer)
        await autoFillQuickSwapDai();
      } catch(_) {}
    }
    
    // Auto-fill Quick Swap DAI field with required amount (no buffer)
    async function autoFillQuickSwapDai() {
      try {
        const daiInput = document.getElementById('quick-swap-dai-amount');
        if (!daiInput) return;
        // Skip if user has manually entered a value
        if (daiInput.dataset.userEdited === 'true') return;
        
        // Get contract and required IAM amount directly from contract
        let contract = window.contractConfig && window.contractConfig.contract;
        if (!contract && typeof window.connectWallet === 'function') {
          try { const c = await window.connectWallet(); contract = c && c.contract ? c.contract : contract; } catch(_) {}
        }
        
        if (!contract) return;
        
        // Get required IAM from contract
        let requiredIam = 0;
        try {
          let wei = null;
          if (typeof contract.getRegPrice === 'function') {
            wei = await contract.getRegPrice();
          } else if (window.safeGetRegPrice) {
            wei = await window.safeGetRegPrice(contract);
          }
          if (wei !== null && wei !== undefined) {
            requiredIam = Number(ethers.formatUnits(wei, 18)) || 0;
          }
        } catch(_) {}
        
        // Get current IAM balance
        let currentIam = 0;
        try {
          if (window.ethereum) {
            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            const me = await signer.getAddress();
            if (contract && typeof contract.balanceOf === 'function') {
              const bal = await contract.balanceOf(me);
              currentIam = Number(ethers.formatUnits(bal, 18)) || 0;
            }
          }
        } catch(_) {}
        
        const needIam = Math.max(0, requiredIam - currentIam);
        
        if (needIam <= 0) {
          daiInput.value = '';
          return;
        }
        
        // Get token price
        let price = 1;
        try {
          if (contract && typeof contract.getTokenPrice === 'function') {
            const p = await contract.getTokenPrice();
            price = Number(ethers.formatUnits(p, 18)) || 1;
          }
        } catch(_) {}
        
        // Calculate DAI needed with 10% buffer
        let needDai = needIam * price * 1.10;
        needDai = Math.ceil(needDai * 10000) / 10000;
        
        if (needDai > 0) {
          daiInput.value = needDai.toFixed(4);
          // Trigger estimate update
          try { daiInput.dispatchEvent(new Event('input', { bubbles: true })); } catch(_) {}
        }
      } catch(_) {}
    }

    async function performDirectBuy(){
      const status = document.getElementById('buy-status');
      const btn = document.getElementById('direct-buy-btn');
      const input = document.getElementById('buy-dai-amount');
      function showBuyStatus(text, type){
        if (!status) return;
        status.style.display = 'block';
        status.className = 'register-form-status ' + (type || 'loading');
        status.textContent = text;
      }
      try {
        if (!window.ethereum) throw new Error('Wallet not connected');
        if (btn) btn.disabled = true;
        const provider = new ethers.BrowserProvider(window.ethereum);
        // ensure contract present
        let contract = window.contractConfig && window.contractConfig.contract;
        if (!contract && typeof window.connectWallet === 'function') {
          try { const conn = await window.connectWallet(); contract = conn && conn.contract ? conn.contract : contract; } catch(_) {}
        }
        if (!contract) throw new Error('Contract not available');
        let daiAmount = parseFloatSafe(input && input.value);
        if (!isFinite(daiAmount) || daiAmount <= 0) {
          // Compute on-the-fly from shortage
          const reqText = (document.getElementById('required-cost-text') && document.getElementById('required-cost-text').textContent) || '0';
          const iamText = (document.getElementById('IAM-balance') && document.getElementById('IAM-balance').textContent) || '0';
          const needIam = Math.max(0, (parseFloatSafe(reqText) - parseFloatSafe(iamText)) || 0);
          if (needIam <= 0) throw new Error('Balance sufficient, nothing to buy');
          let price = 1;
          try {
            if (typeof contract.getTokenPrice === 'function') {
              const p = await contract.getTokenPrice();
              price = Number(ethers.formatUnits(p, 18)) || 1;
            }
          } catch(_) {}
          let needDai = needIam * price * 1.10; // add 10% buffer on click as well
          needDai = Math.ceil(needDai * 10000) / 10000;
          daiAmount = needDai;
        }
        // Approve DAI to contract
        const dai = await getDaiContract(provider);
        if (!dai) throw new Error('DAI token not configured');
        const decimals = (await dai.decimals?.().catch(()=>18)) || 18;
        const daiWei = ethers.parseUnits(daiAmount.toString(), decimals);
        showBuyStatus('Approving DAI...', 'loading');
        const ap = await dai.approve(contract.target || contract.address, daiWei);
        await ap.wait();
        // Buy
        showBuyStatus('Buying IAM with DAI...', 'loading');
        let tx;
        if (typeof contract.buyTokens === 'function') {
          tx = await contract.buyTokens(daiWei);
        } else if (typeof contract.buyTokensWithDAI === 'function') {
          tx = await contract.buyTokensWithDAI(daiWei);
        } else if (typeof contract.swapDAIForTokens === 'function') {
          tx = await contract.swapDAIForTokens(daiWei);
        } else {
          throw new Error('Direct buy not supported, use Swap');
        }
        await tx.wait();
        showBuyStatus('✅ Purchase confirmed. Updating balance...', 'success');
        // Refresh availability
        try { await refreshBalancesAndAvailability(); } catch(_) {}
        try { await updateBuyEstimates(); } catch(_) {}
        try { await autoFillQuickSwapDai(); } catch(_) {}
        // Post-check: still shortage?
        try {
          const reqText2 = (document.getElementById('required-cost-text') && document.getElementById('required-cost-text').textContent) || '0';
          const iamText2 = (document.getElementById('IAM-balance') && document.getElementById('IAM-balance').textContent) || '0';
          const remaining = Math.max(0, (parseFloatSafe(reqText2) - parseFloatSafe(iamText2)) || 0);
          if (remaining > 0 && status) {
            status.style.display = 'block';
            status.className = 'register-form-status warning';
            status.textContent = `⚠️ Still need ${remaining.toFixed(2)} IAM to register`;
          } else if (status) {
            status.style.display = 'block';
            status.className = 'register-form-status success';
            status.textContent = '✅ IAM balance is sufficient. You can register now.';
          }
          enforceRegisterButtonState();
        } catch(_) {}
      } catch(e) {
        const msg = (e && e.message) ? e.message : 'Buy failed';
        showBuyStatus('❌ ' + msg, 'error');
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    document.addEventListener('DOMContentLoaded', function(){
      const buyBtn = document.getElementById('direct-buy-btn');
      if (buyBtn) buyBtn.addEventListener('click', performDirectBuy);
      const daiInput = document.getElementById('buy-dai-amount');
      if (daiInput) daiInput.addEventListener('input', () => {
        const helper = document.getElementById('buy-dai-helper');
        if (helper) helper.textContent = '';
      });
      // Initial fill
      setTimeout(async () => { try {
        let conn = null;
        if (typeof window.connectWallet === 'function') {
          try { conn = await window.connectWallet(); } catch(_) {}
        }
        await refreshBuyCardBalances(conn || {});
      } catch(_) {} }, 300);
      // Periodic refresh while page open
      setInterval(async () => { try {
        await refreshBuyCardBalances(window.contractConfig || {});
        enforceRegisterButtonState();
      } catch(_) {} }, 8000);
    });
  </script>
  
  <script>
    async function updateRegistrationCost(){
      try {
        const box = document.getElementById('required-cost-box');
        const txt = document.getElementById('required-cost-text');
        if (!box || !txt) return;
        let conn = window.contractConfig;
        if ((!conn || !conn.contract || !conn.address) && typeof window.connectWallet === 'function') {
          try { conn = await window.connectWallet(); } catch(_) {}
        }
        const contract = conn && conn.contract ? conn.contract : null;
        const userAddr = conn && conn.address ? conn.address : null;
        if (!contract || !userAddr) return;
        // Compute needed IAM = max(regPrice - userIAM, 0)
        let regIAM = 0;
        try {
          let wei = null;
          if (typeof contract.getRegPrice === 'function') {
            wei = await contract.getRegPrice();
          } else if (window.safeGetRegPrice) {
            wei = await window.safeGetRegPrice(contract);
          }
          if (wei !== null && wei !== undefined) regIAM = Number(ethers.formatUnits(wei, 18)) || 0;
        } catch(_) {}
        let userIAM = 0;
        try {
          if (typeof contract.balanceOf === 'function') {
            const bal = await contract.balanceOf(userAddr);
            userIAM = Number(ethers.formatUnits(bal, 18)) || 0;
          }
        } catch(_) {}
        const needed = Math.max(0, regIAM - userIAM);
        txt.textContent = `${needed.toFixed(2)} IAM`;
        // Update buy-required-iam with regPrice directly (not needed amount)
        const buyNeed = document.getElementById('buy-required-iam');
        if (buyNeed) buyNeed.textContent = regIAM > 0 ? regIAM.toFixed(2) : '...';
        box.style.display = 'block';
      } catch(_) {}
    }
    // Listen for wallet connection from common auto-connect function
    window.addEventListener('walletConnected', async function(event) {
      const conn = event.detail;
      if (!conn || !conn.address) return;
      
      console.log('✅ Wallet connected on register page:', conn.address);
      
      // Set new user field to connected address ONLY if user is inactive
      try {
        const nu = document.getElementById('new-user-address');
        if (nu && conn.contract) {
          let userActive = false;
          let userIndex = null;
          try {
            const u = await conn.contract.users(conn.address);
            // Support both 'index' (old) and 'num' (new contract) field names
            const userNum = u && (u.num !== undefined ? u.num : (u.index !== undefined ? u.index : undefined));
            userActive = !!(userNum && BigInt(userNum) > 0n);
            if (userActive) {
              userIndex = Number(userNum);
            }
          } catch(_) {}
          
          if (!userActive) {
            nu.value = conn.address;
            nu.setAttribute('data-full-address', conn.address);
          } else {
            // Always auto-fill referrer fields with connected wallet address
            await autoFillReferrerFields(conn.address, userIndex);
            console.log('🔗 Referrer set to connected wallet address:', conn.address);
          }
        }
      } catch(_) {}
      
      // Fetch and show registration price
      try {
        const box = document.getElementById('reg-price-box');
        const txt = document.getElementById('reg-price-text');
        if (box && txt && conn.contract) {
          const wei = await (window.safeGetRegPrice ? window.safeGetRegPrice(conn.contract) : null);
          if (wei !== null && wei !== undefined) {
            const val = (typeof ethers !== 'undefined') ? ethers.formatUnits(wei, 18) : String(wei);
            txt.textContent = `${Number(val).toFixed(2)} IAM`;
            box.style.display = 'block';
          }
        }
      } catch(e) { console.warn('Reg price fetch failed:', e && (e.message||e)); }

      // Also update required cost box now that we are connected
      try { await updateRegistrationCost(); } catch(_) {}

      // Fetch and populate balances box
      try {
        const mEl = document.getElementById('matic-balance');
        const iEl = document.getElementById('IAM-balance');
        if (mEl && iEl) {
          const provider = conn.provider || (window.contractConfig && window.contractConfig.provider);
          if (provider) {
            const mBal = await provider.getBalance(conn.address);
            const mNum = ethers.formatUnits(mBal, 18);
            mEl.textContent = Number(mNum).toFixed(4);
          }
          try {
            const c = conn.contract || (window.contractConfig && window.contractConfig.contract);
            if (c && typeof c.balanceOf === 'function') {
              const ib = await c.balanceOf(conn.address);
              const iNum = ethers.formatUnits(ib, 18);
              iEl.textContent = Number(iNum).toFixed(2);
            }
          } catch(_) {}
        }
      } catch(_) {}
      try { await refreshBuyCardBalances(conn); } catch(_) {}
      // Ensure button state is updated after balances are refreshed
      setTimeout(() => {
        try { enforceRegisterButtonState(); } catch(_) {}
      }, 500);
      enforceRegisterButtonState();
    });
    
    // Also try to connect if already connected (for page refresh scenarios)
    document.addEventListener('DOMContentLoaded', async function(){
      // Check if wallet is already connected
      if (window.contractConfig && window.contractConfig.contract && window.contractConfig.address) {
        try {
          const event = new CustomEvent('walletConnected', { detail: window.contractConfig });
          window.dispatchEvent(event);
        } catch(_) {}
      }

      // Add retry button functionality
      const retryBtn = document.getElementById('retry-wallet-btn');
      if (retryBtn) {
        retryBtn.addEventListener('click', async function() {
          console.log('🔄 Manual wallet retry requested...');
          retryBtn.disabled = true;
          retryBtn.textContent = '⏳ Connecting...';
          
          try {
            if (typeof window.connectWallet === 'function') {
              const conn = await window.connectWallet();
              if (conn && conn.address) {
                console.log('✅ Manual wallet connection successful:', conn.address);
                const statusEl = document.getElementById('status-message');
                const retrySection = document.getElementById('wallet-retry-section');
                
                if (statusEl) {
                  statusEl.className = 'register-form-status success';
                  statusEl.textContent = '✅ Wallet connected successfully!';
                }
                if (retrySection) {
                  retrySection.style.display = 'none';
                }
                
                // Trigger walletConnected event
                const event = new CustomEvent('walletConnected', { detail: conn });
                window.dispatchEvent(event);
              } else {
                throw new Error('Wallet connection failed');
              }
            } else {
              throw new Error('Wallet connection not available');
            }
          } catch (error) {
            console.error('❌ Manual wallet retry failed:', error);
            const statusEl = document.getElementById('status-message');
            if (statusEl) {
              statusEl.className = 'register-form-status error';
              statusEl.textContent = '❌ Wallet connection failed. Please check MetaMask and try again.';
            }
          } finally {
            retryBtn.disabled = false;
            retryBtn.textContent = '🔄 Retry Wallet Connection';
          }
        });
      }

      // Keep new user field in sync with account changes
      if (window.ethereum && window.ethereum.on) {
        try {
          window.ethereum.on('accountsChanged', async (accounts) => {
            const addr = (accounts && accounts[0]) ? accounts[0] : null;
            const nu = document.getElementById('new-user-address');
            if (nu && addr) {
              // Only fill New User if account is inactive
              try {
                let contract = (window.contractConfig && window.contractConfig.contract) || null;
                if (!contract && typeof window.connectWallet === 'function') {
                  const c = await window.connectWallet();
                  contract = c && c.contract ? c.contract : contract;
                }
                let userActive = false;
                if (contract) {
                  try {
                    const u = await contract.users(addr);
                    // Support both 'index' (old) and 'num' (new contract) field names
                    const userNum = u && (u.num !== undefined ? u.num : (u.index !== undefined ? u.index : undefined));
                    userActive = !!(userNum && BigInt(userNum) > 0n);
                  } catch(_) {}
                }
                if (!userActive) {
                  nu.value = addr;
                  nu.setAttribute('data-full-address', addr);
                } else {
                  // If user is active, update referrer fields with new wallet address
                  try {
                    const contract = (window.contractConfig && window.contractConfig.contract) || null;
                    if (contract) {
                      const u = await contract.users(addr);
                      // Support both 'index' (old) and 'num' (new contract) field names
                      const userNum = u && (u.num !== undefined ? u.num : (u.index !== undefined ? u.index : undefined));
                      const userIndex = userNum ? Number(userNum) : null;
                      if (userIndex) {
                        await autoFillReferrerFields(addr, userIndex);
                        console.log('🔗 Referrer updated to new wallet address:', addr);
                      }
                    }
                  } catch(_) {}
                }
              } catch(_) {}
            }
            // Refresh registration price on account change
            try {
              if (typeof window.connectWallet === 'function') {
                const conn = await window.connectWallet();
                const box = document.getElementById('reg-price-box');
                const txt = document.getElementById('reg-price-text');
                if (box && txt && conn && conn.contract) {
                  const wei = await (window.safeGetRegPrice ? window.safeGetRegPrice(conn.contract) : null);
                  if (wei !== null && wei !== undefined) {
                    const val = (typeof ethers !== 'undefined') ? ethers.formatUnits(wei, 18) : String(wei);
                    txt.textContent = `${Number(val).toFixed(2)} IAM`;
                    box.style.display = 'block';
                  }
                }
              }
            } catch(_) {}

            // Refresh required cost box
            try { await updateRegistrationCost(); } catch(_) {}
            enforceRegisterButtonState();
          });
        } catch(_) {}
      }
    });
  </script>
  
  <script>
    // When clicking on the Required chip, prefill the Quick Swap DAI amount with the needed DAI
    (function(){
      function parseNumSafe(v){
        const n = parseFloat(v);
        return isFinite(n) ? n : 0;
      }
      async function getTokenPriceSafe(){
        try {
          let contract = window.contractConfig && window.contractConfig.contract;
          if (!contract && typeof window.connectWallet === 'function') {
            try { const c = await window.connectWallet(); contract = c && c.contract ? c.contract : contract; } catch(_) {}
          }
          if (contract && typeof contract.getTokenPrice === 'function') {
            const p = await contract.getTokenPrice();
            if (window.ethers && window.ethers.formatUnits) {
              const price = Number(window.ethers.formatUnits(p, 18));
              return isFinite(price) && price > 0 ? price : 1;
            } else if (window.ethers && window.ethers.utils && window.ethers.utils.formatUnits) {
              const price = Number(window.ethers.utils.formatUnits(p, 18));
              return isFinite(price) && price > 0 ? price : 1;
            }
          }
        } catch(_) {}
        return 1;
      }
      async function handleRequiredClick(){
        try {
          const reqText = (document.getElementById('buy-required-iam') && document.getElementById('buy-required-iam').textContent) || (document.getElementById('required-cost-text') && document.getElementById('required-cost-text').textContent) || '0';
          const iamBalText = (document.getElementById('buy-current-iam') && document.getElementById('buy-current-iam').textContent) || (document.getElementById('IAM-balance') && document.getElementById('IAM-balance').textContent) || '0';
          const needIam = Math.max(0, parseNumSafe(reqText) - parseNumSafe(iamBalText));
          const price = await getTokenPriceSafe();
          let needDai = needIam * price;
          needDai = Math.ceil(needDai * 10000) / 10000;
          const input = document.getElementById('quick-swap-dai-amount');
          if (input) {
            input.value = needDai > 0 ? needDai.toFixed(4) : '';
            // Trigger estimate update in Quick Swap
            try { input.dispatchEvent(new Event('input', { bubbles: true })); } catch(_) {}
            input.focus();
          }
        } catch(_) {}
      }
      document.addEventListener('click', function(e){
        const target = e.target;
        if (!target) return;
        // Click on the bold number or its containing chip
        if (target.id === 'buy-required-iam' || (target.closest && target.closest('#buy-section') && target.closest('div') && target.closest('div').textContent && target.closest('div').textContent.includes('Required:') && target.closest('div').querySelector('#buy-required-iam'))) {
          handleRequiredClick();
        }
      });
    })();
  </script>
  <script>
    let selectedAvatar = 'man';
    
    // Contract addresses
    const IAM_ADDRESS_NEW = '0xa4C37107AbaeD664978e5f6db79249Ad08Fe0dBf'; // New contract
    
    // Default to new contract (override global if exists)
    window.IAM_ADDRESS = IAM_ADDRESS_NEW;
    


    // Show status message
    function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('status-message');
        if (!statusEl) return;
        
        let className = 'register-form-status';
        let icon = '';
        
        switch(type) {
            case 'success':
                className += ' success';
                icon = '✅ ';
                break;
            case 'error':
                className += ' error';
                icon = '❌ ';
                break;
            case 'loading':
                className += ' loading';
                icon = '⏳ ';
                break;
            default:
                className += ' info';
                icon = 'ℹ️ ';
        }
        
        statusEl.className = className;
        statusEl.textContent = icon + message;
    }

                                                // Note: isIndexInUserSubtree function removed - now using contract's isInDownline function

          // Function to auto-fill referrer fields with current user's info
          async function autoFillReferrerFields(userAddress, userIndex) {
            try {
              console.log(`🔄 Auto-filling referrer fields for active user: ${userAddress} (Index: ${userIndex})`);
              
              // Fill referrer address field
              const referrerDisplay = document.getElementById('referrer-address-display');
              if (referrerDisplay) {
                referrerDisplay.value = userAddress;
                referrerDisplay.setAttribute('data-full-address', userAddress);
                if (userIndex) referrerDisplay.setAttribute('data-index', userIndex);
                updateAddressDisplay(referrerDisplay);
                // keep editable
                referrerDisplay.readOnly = false;
                referrerDisplay.style.backgroundColor = '';
                referrerDisplay.style.color = '';
                referrerDisplay.style.cursor = '';
                referrerDisplay.placeholder = 'Enter referrer wallet address or index';
              }
              
              // Fill upper address field (keep editable)
              const upperInput = document.getElementById('upper-address');
              if (upperInput) {
                upperInput.value = userAddress;
                upperInput.setAttribute('data-full-address', userAddress);
                if (userIndex) upperInput.setAttribute('data-index', userIndex);
                updateAddressDisplay(upperInput);
                // keep editable
                upperInput.readOnly = false;
                upperInput.style.backgroundColor = '';
                upperInput.style.color = '';
                upperInput.style.cursor = '';
                upperInput.placeholder = 'Enter upper wallet address or index';
              }
              
              // Show success message
              showTempMessage(`✅ Auto-filled referrer fields with your info (Index: ${userIndex}) - Referrer locked, Upper editable`, 'success');
              
              // Trigger validation
              setTimeout(async () => {
                await validateUpperAgainstReferrer();
                await calculatePlacementForNewUser();
              }, 500);
              
            } catch (error) {
              console.error('Error auto-filling referrer fields:', error);
            }
          }

          // Function to check if current user can register for the given address
          async function canUserRegisterForAddress(targetAddress, addressType) {
            try {
              if (!window.contractConfig || !window.contractConfig.contract) {
                console.log('❌ Contract not available');
                return false;
              }
              
              const contract = window.contractConfig.contract;
              
              // Get current user info
              let myAddress = null;
              let myUser = null;
              try {
                // Try multiple methods to get current user address
                if (window.currentUserAddress) {
                  myAddress = window.currentUserAddress;
                } else if (contract.signer) {
                  myAddress = await contract.signer.getAddress();
                } else if (window.ethereum && window.ethereum.selectedAddress) {
                  myAddress = window.ethereum.selectedAddress;
                } else if (window.contractConfig && window.contractConfig.address) {
                  myAddress = window.contractConfig.address;
                }
                
                if (myAddress) {
                  myUser = await contract.users(myAddress);
                  window.currentUserAddress = myAddress;
                }
              } catch (e) {
                console.log('Error getting current user:', e);
                return false;
              }
              
              // If we still don't have an address, return false
              if (!myAddress) {
                console.log('❌ Could not determine current user address');
                return false;
              }
              
              // If target is the same as current user, it's always allowed
              if (myAddress && targetAddress && targetAddress.toLowerCase() === myAddress.toLowerCase()) {
                console.log(`✅ Can register for self (${addressType})`);
                return true;
              }
              
              // For inactive users, allow registration for any active referrer/upper
              const myNum = myUser && (myUser.num !== undefined ? myUser.num : (myUser.index !== undefined ? myUser.index : undefined));
              if (!myUser || !(myNum && BigInt(myNum) > 0n)) {
                console.log(`ℹ️ Current user is not active. Allowing registration with any active ${addressType}.`);
                return true; // Allow inactive users to register with any active referrer/upper
              }
              
          // For active users, check if target is in their downline or is themselves using contract function
          const targetUser = await contract.users(targetAddress);
          const targetNum = (targetUser && (targetUser.num !== undefined ? targetUser.num : (targetUser.index !== undefined ? targetUser.index : undefined)));
          if (!targetUser || !(targetNum && BigInt(targetNum) > 0n)) {
            console.log(`❌ Target ${addressType} is not active`);
            return false;
          }
          
          // Use contract's isInDownline function to check if target is in current user's downline
          let isInDownline = false;
          try {
            if (typeof contract.isInDownline === 'function') {
              // Check: isInDownline(ancestor, descendant) - is target in current user's downline?
              isInDownline = await contract.isInDownline(myAddress, targetAddress);
              console.log(`🔍 Contract isInDownline(${myAddress}, ${targetAddress}) = ${isInDownline}`);
            } else if (typeof contract.isAncestor === 'function') {
              // Fallback: use isAncestor to check if current user is ancestor of target
              isInDownline = await contract.isAncestor(myAddress, targetAddress);
              console.log(`🔍 Contract isAncestor(${myAddress}, ${targetAddress}) = ${isInDownline}`);
            } else {
              console.warn('⚠️ Contract does not have isInDownline or isAncestor function');
              return false;
            }
          } catch (contractError) {
            console.error(`❌ Error calling contract validation function:`, contractError);
            return false;
          }
          
          // Check if target is in current user's downline or is the same user
          if (isInDownline) {
            console.log(`✅ Can register for ${addressType} (in downline)`);
            return true;
          }
          
          console.log(`❌ Cannot register for ${addressType} (not in downline)`);
          return false;
              
            } catch (error) {
              console.error(`❌ Error checking registration permission:`, error);
              return false;
            }
          }

    // Function to validate referrer and upper relationship using contract's isInDownline function
    async function validateReferrerUpperRelationship(contract, referrer, upper) {
      console.log(`🔍 Validating referrer-upper relationship: referrer=${referrer}, upper=${upper}`);
      
      // If referrer and upper are the same, it's valid
      if (referrer.toLowerCase() === upper.toLowerCase()) {
        console.log(`✅ Referrer and upper are the same - valid`);
        return;
      }
      
      try {
        // Get referrer user data to check if active
        const referrerUser = await contract.users(referrer);
        const refNum = (referrerUser && (referrerUser.num !== undefined ? referrerUser.num : referrerUser.index));
        if (!referrerUser || !(refNum !== undefined && BigInt(refNum) > 0n)) {
          throw new Error('Referrer is not active or does not exist');
        }
        
        // Get upper user data to check if active
        const upperUser = await contract.users(upper);
        const upperNum = (upperUser && (upperUser.num !== undefined ? upperUser.num : upperUser.index));
        if (!upperUser || !(upperNum !== undefined && BigInt(upperNum) > 0n)) {
          throw new Error('Upper address is not active or does not exist');
        }
        
        // Use contract's isInDownline function to check if upper is in referrer's downline
        let isInDownline = false;
        try {
          if (typeof contract.isInDownline === 'function') {
            // Check: isInDownline(ancestor, descendant) - is upper in referrer's downline?
            isInDownline = await contract.isInDownline(referrer, upper);
            console.log(`🔍 Contract isInDownline(${referrer}, ${upper}) = ${isInDownline}`);
          } else {
            // Fallback: try isAncestor if available (note: this checks reverse relationship)
            console.warn('⚠️ isInDownline not found, trying alternative methods');
            // If isAncestor exists, it checks if first is ancestor of second
            // So we need: isAncestor(referrer, upper) to check if referrer is ancestor of upper
            if (typeof contract.isAncestor === 'function') {
              isInDownline = await contract.isAncestor(referrer, upper);
              console.log(`🔍 Contract isAncestor(${referrer}, ${upper}) = ${isInDownline}`);
            } else {
              throw new Error('Contract does not have isInDownline or isAncestor function');
            }
          }
        } catch (contractError) {
          console.error('❌ Error calling contract validation function:', contractError);
          throw new Error('Failed to validate relationship using contract: ' + (contractError.message || contractError));
        }
        
        if (isInDownline) {
          console.log(`✅ Upper address is in referrer's downline - valid`);
          return;
        } else {
          throw new Error('Upper address must be either the same as referrer or in referrer\'s downline');
        }
        
      } catch (error) {
        console.error(`❌ Validation error:`, error);
        throw error;
      }
    }
      

      
          // Avatar selection
    document.querySelectorAll('.avatar-choice').forEach(el => {
      el.onclick = function() {
        document.querySelectorAll('.avatar-choice').forEach(e2 => e2.classList.remove('selected'));
        this.classList.add('selected');
        selectedAvatar = this.getAttribute('data-avatar');
      };
    });

     // Change registration type based on selected tab
     let currentRegistrationType = 'normal';
     
     
     
     // Function to update registration cost
     async function updateRegistrationCost() {
       // Normal mode: use safe regPrice function
       try {
         if (window.contractConfig && window.contractConfig.contract) {
           const contract = window.contractConfig.contract;
           const regPrice = await (window.safeGetRegPrice ? window.safeGetRegPrice(contract) : null);
           if (regPrice) {
             const regPriceNum = Number(ethers.formatUnits(regPrice, 18));
             document.getElementById('register-cost').textContent = `${regPriceNum.toFixed(2)} IAM`;
           } else {
             document.getElementById('register-cost').textContent = 'RegPrice not available';
           }
         } else {
           document.getElementById('register-cost').textContent = 'Contract not available';
         }
       } catch (e) {
         document.getElementById('register-cost').textContent = 'Error loading regPrice';
       }
     }



         // Initialize information (simplified without wallet connection)
    async function loadRegisterInfo() {
      const status = document.getElementById('status-message');
      status.textContent = '';
      
      // Enable form elements
      const registerInfoElement = document.getElementById('register-info');
      if (registerInfoElement) {
        registerInfoElement.style.display = '';
      }
      document.getElementById('register-btn').disabled = false;
      document.querySelectorAll('input').forEach(i=>i.disabled=false);
      
      // Show registration suggestion
      const suggestionDiv = document.getElementById('register-suggestion');
      if (suggestionDiv) {
        suggestionDiv.style.display = 'none';
        suggestionDiv.textContent = '';
      }
      
      // Clear all fields for manual input
      const referrerDisplay = document.getElementById('referrer-address-display');
      const upperInput = document.getElementById('upper-address');
      const newUserInputElement = document.getElementById('new-user-address');
      
      if (referrerDisplay) {
        referrerDisplay.value = '';
        referrerDisplay.placeholder = 'Enter referrer wallet address';
      }
      if (upperInput) {
        upperInput.value = '';
        upperInput.placeholder = 'Enter upper wallet address';
      }
      if (newUserInputElement) {
        newUserInputElement.value = '';
        newUserInputElement.placeholder = 'Enter new user wallet address';
      }
      
      // Update address displays
      if (referrerDisplay) updateAddressDisplay(referrerDisplay);
      if (upperInput) updateAddressDisplay(upperInput);
      if (newUserInputElement) updateAddressDisplay(newUserInputElement);
      
      // Set default values for balance displays
      const maticBalanceElement = document.getElementById('matic-balance');
      if (maticBalanceElement) {
        maticBalanceElement.textContent = 'N/A';
      }
      
      const IAMBalanceElement = document.getElementById('IAM-balance');
      if (IAMBalanceElement) {
        IAMBalanceElement.textContent = 'N/A';
      }
    }
         window.addEventListener('DOMContentLoaded', loadRegisterInfo);
     

         

    // --- Manual index application with button ---
    // Event listeners are now set up in the main DOMContentLoaded function

    // Function to apply index to address field (now takes value directly)
    async function applyIndexToAddress(valueOrInput, addressInput, type) {
      // Support both direct value (string) or input element for backward compatibility
      const value = typeof valueOrInput === 'string' ? valueOrInput.trim() : (valueOrInput?.value || '').trim();
      console.log(`🔍 Applying ${type} number/address: ${value}`);
      
      if (!value) {
        showTempMessage(`Please enter a valid ${type} number or address`, 'error');
        return;
      }
      
      try {
        // Ensure wallet connection and contract instance
        let contract = null;
        try {
          if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            contract = conn && conn.contract ? conn.contract : (window.contractConfig && window.contractConfig.contract);
          } else {
            contract = window.contractConfig && window.contractConfig.contract;
          }
        } catch(_) {}
        if (!contract) {
          showTempMessage('Wallet not connected. Please connect wallet first.', 'error');
          return;
        }
        
        // Check if input is already an address
        if (/^0x[a-fA-F0-9]{40}$/.test(value)) {
          // Input is already an address, use it directly
          addressInput.value = value;
          addressInput.setAttribute('data-full-address', value);
          updateAddressDisplay(addressInput);
          showTempMessage(`${type} address set successfully`, 'success');
          if (type === 'upper') {
            await validateUpperAgainstReferrer();
          }
          return;
        }
        
        // Extract numeric number
        let index = value;
        if (value.startsWith('IAM')) {
          index = value.substring(3);
        }
        index = index.replace(/[^0-9]/g, '');
        
        if (!index || index.length > 8) {
          showTempMessage(`Invalid ${type} number format`, 'error');
          return;
        }
        
        // Get address from number (use getAddressByNumber for new contract, fallback to indexToAddress for old)
        let address = null;
        try {
          if (typeof contract.getAddressByNumber === 'function') {
            address = await contract.getAddressByNumber(parseInt(index));
          } else if (typeof contract.indexToAddress === 'function') {
            address = await contract.indexToAddress(BigInt(index));
          }
        } catch (e) {
          console.error(`Error getting address for ${type}:`, e);
          showTempMessage(`Error: ${type} number does not exist or contract error`, 'error');
          return;
        }
        
        if (!address || address === '0x0000000000000000000000000000000000000000') {
          showTempMessage(`${type} number does not exist`, 'error');
          return;
        }
        
        // Set the address (store full address, display truncated)
        addressInput.value = address;
        addressInput.setAttribute('data-full-address', address);
        addressInput.setAttribute('data-index', index); // Store index for display
        addressInput.style.backgroundColor = '#232946';
        addressInput.style.color = '#fff';
        
        // Update display with truncated address and index
        updateAddressDisplay(addressInput);
        
        showTempMessage(`${type} address set successfully`, 'success');
        console.log(`✅ ${type} address set: ${address}`);
        
        // If this is upper address, validate against referrer and show placement info
        if (type === 'upper') {
          await validateUpperAgainstReferrer();
        }
        
      } catch (error) {
        console.error(`Error applying ${type} index:`, error);
        showTempMessage(`Error applying ${type} index: ${error.message}`, 'error');
      }
    }
     

         // Address field event listeners are now set up in setupEventListeners function
     
    // Function to truncate address for display
    function truncateAddress(address) {
      if (!address || address.length < 10) return address;
      return address.substring(0, 6) + '...' + address.substring(address.length - 4);
    }
    
    // Function to update address display with truncation and index suffix
    function updateAddressDisplay(addressInput) {
      const fullAddress = addressInput.getAttribute('data-full-address') || addressInput.value;
      let display = fullAddress;
      if (fullAddress && fullAddress.length > 10) {
        display = truncateAddress(fullAddress);
      }
      // Append corresponding index after address if available from data attribute
      try {
        const idx = addressInput.getAttribute('data-index') || '';
        if (idx) {
          display = display + ' (' + idx + ')';
        }
      } catch(_) {}
      addressInput.value = display;
    }
    
    // Function to check address validity
    async function checkAddressValidity(addressInput, type) {
      const address = addressInput.value.trim();
      if (!/^0x[a-fA-F0-9]{40}$/.test(address)) return;
      
      try {
        // Ensure wallet connection and contract instance
        let contract = null;
        try {
          if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            contract = conn && conn.contract ? conn.contract : (window.contractConfig && window.contractConfig.contract);
          } else {
            contract = window.contractConfig && window.contractConfig.contract;
          }
        } catch(_) {}
        if (!contract) {
          showTempMessage('Wallet not connected. Please connect wallet first.', 'error');
          return;
        }
        
        // Check if current user can register for this address
        const canRegister = await canUserRegisterForAddress(address, type);
        if (!canRegister) {
          showTempMessage(`You can only register for yourself or your downlines. This ${type} is not in your downline.`, 'error');
          return;
        }
        
        // Check if address is active (for referrer/upper validation)
        const user = await contract.users(address);
        // Support both 'index' (old) and 'num' (new contract) field names
        const userNum = user && (user.num !== undefined ? user.num : (user.index !== undefined ? user.index : undefined));
        if (!user || !(userNum && BigInt(userNum) > 0n)) {
          showTempMessage(`${type} address is not active`, 'error');
          return;
        }
        
        showTempMessage(`${type} address is valid and you can register for it`, 'success');
      } catch (e) {
        showTempMessage(`Error checking ${type} address: ${e.message}`, 'error');
      }
    }
    
    // Function to validate upper address against referrer in real-time
    async function validateUpperAgainstReferrer() {
      const statusEl = document.getElementById('upper-validation-status');
      if (!statusEl) return;
      
      // Always hide status message
      statusEl.style.display = 'none';
      
      const referrer = referrerDisplay.getAttribute('data-full-address') || referrerDisplay.value.trim();
      const upper = upperInput.getAttribute('data-full-address') || upperInput.value.trim();
      
      // Reset field colors to default
      const referrerField = document.getElementById('referrer-address-display');
      const upperField = document.getElementById('upper-address');
      const referrerIndexField = document.getElementById('referrer-index');
      const upperIndexField = document.getElementById('upper-index');
      
      // Default border color
      const defaultBorder = '1px solid var(--border)';
      
      if (!referrer || referrer === 'root') {
        if (referrerField) referrerField.style.border = defaultBorder;
        if (upperField) upperField.style.border = defaultBorder;
        if (referrerIndexField) referrerIndexField.style.border = defaultBorder;
        if (upperIndexField) upperIndexField.style.border = defaultBorder;
        return;
      }
      if (!/^0x[a-fA-F0-9]{40}$/.test(referrer)) {
        if (referrerField) referrerField.style.border = defaultBorder;
        if (upperField) upperField.style.border = defaultBorder;
        if (referrerIndexField) referrerIndexField.style.border = defaultBorder;
        if (upperIndexField) upperIndexField.style.border = defaultBorder;
        return;
      }
      
      try {
        if (!window.contractConfig || !window.contractConfig.contract) {
          if (referrerField) referrerField.style.border = defaultBorder;
          if (upperField) upperField.style.border = defaultBorder;
          if (referrerIndexField) referrerIndexField.style.border = defaultBorder;
          if (upperIndexField) upperIndexField.style.border = defaultBorder;
          return;
        }
        const contract = window.contractConfig.contract;
        
        if (currentRegistrationType === 'normal') {
          // Normal registration: validate upper against referrer
          if (!upper || upper === 'root' || !/^0x[a-fA-F0-9]{40}$/.test(upper)) {
            if (referrerField) referrerField.style.border = defaultBorder;
            if (upperField) upperField.style.border = defaultBorder;
            if (referrerIndexField) referrerIndexField.style.border = defaultBorder;
            if (upperIndexField) upperIndexField.style.border = defaultBorder;
            return;
          }
          
          // Check if upper is in referrer's subtree (subtree check)
          try {
          await validateReferrerUpperRelationship(contract, referrer, upper);
            // Upper is in referrer's subtree - Set green border for all fields
            if (referrerField) referrerField.style.border = '2px solid #00ff88';
            if (upperField) upperField.style.border = '2px solid #00ff88';
            if (referrerIndexField) referrerIndexField.style.border = '2px solid #00ff88';
            if (upperIndexField) upperIndexField.style.border = '2px solid #00ff88';
          } catch (error) {
            // Upper is NOT in referrer's subtree - Set red border for all fields
            if (referrerField) referrerField.style.border = '2px solid #ff6b6b';
            if (upperField) upperField.style.border = '2px solid #ff6b6b';
            if (referrerIndexField) referrerIndexField.style.border = '2px solid #ff6b6b';
            if (upperIndexField) upperIndexField.style.border = '2px solid #ff6b6b';
          }
        } else {
          // For non-normal registration, just validate referrer
          if (referrerField) referrerField.style.border = '2px solid #00ff88';
          if (referrerIndexField) referrerIndexField.style.border = '2px solid #00ff88';
        }
      } catch (error) {
        // Set red border for all fields on error
        if (referrerField) referrerField.style.border = '2px solid #ff6b6b';
        if (upperField) upperField.style.border = '2px solid #ff6b6b';
        if (referrerIndexField) referrerIndexField.style.border = '2px solid #ff6b6b';
        if (upperIndexField) upperIndexField.style.border = '2px solid #ff6b6b';
      }
    }
    
    
     

     

     
            // Event listeners for newUserInput are now set up in setupEventListeners function
       
             // Function to check new user address
        async function checkNewUserAddress() {
        const address = newUserInput.value.trim();
        const status = document.getElementById('status-message');
        
                 // اگر آدرس خالی است، پیام را پاک کن
         if (!address) {
           status.textContent = '';
           return;
         }
         
         // بررسی فرمت آدرس
         if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
           status.style.color = '#d32f2f';
           status.textContent = 'The entered address is not valid. Please enter a correct address.';
           return;
         }
        
        try {
          // Function disabled - requires wallet connection
          status.style.color = '#d32f2f';
          status.textContent = 'This function requires wallet connection.';
          return;
          
          // دریافت آدرس کاربر جاری
          let myAddress = null;
          try {
            if (window.currentUserAddress) {
              myAddress = window.currentUserAddress;
            } else {
              myAddress = contract.signer ? await contract.signer.getAddress() : null;
              if (myAddress) {
                window.currentUserAddress = myAddress;
              }
            }
          } catch (e) {
            console.log(`خطا در دریافت آدرس کاربر جاری:`, e);
          }
          
                     // بررسی اینکه آیا این آدرس قبلاً ثبت‌نام شده است
           const user = await contract.users(address);
           // Support both 'index' (old) and 'num' (new contract) field names
           const userNum = user && (user.num !== undefined ? user.num : (user.index !== undefined ? user.index : undefined));
           if (userNum && BigInt(userNum) > 0n) {
             status.style.color = '#d32f2f';
             status.textContent = 'This address is already registered.';
             return;
           }
           
           // بررسی اینکه آیا کاربر برای خودش ثبت‌نام می‌کند
           if (address.toLowerCase() === myAddress.toLowerCase()) {
             status.style.color = '#388e3c';
             status.textContent = 'You can register for yourself.';
           } else {
             // اگر ثبت‌نام نشده، پیام موفقیت
             status.style.color = '#388e3c';
             status.textContent = 'New user address is valid and can be registered.';
           }
          
                     // نمایش ایندکس مربوط به این آدرس (اگر وجود داشته باشد)
           try {
             // جستجو در ایندکس‌های موجود برای یافتن این آدرس
             let foundIndex = null;
             for (let i = 1; i <= 1000; i++) { // جستجو در 1000 ایندکس اول
               try {
                 const addrAtIndex = await contract.indexToAddress(i);
                 if (addrAtIndex.toLowerCase() === address.toLowerCase()) {
                   foundIndex = i;
                   break;
                 }
               } catch (e) {
                 // اگر ایندکس وجود نداشته باشد، ادامه بده
                 continue;
               }
             }
             
             if (foundIndex) {
               status.textContent += ` (Index: ${foundIndex})`;
             }
                      } catch (e) {
             // اگر خطا در جستجوی ایندکس داشتیم، نادیده بگیر
           }
         } catch (e) {
           showTempMessage('Error checking address: ' + (e.message || e), 'error');
         }
       }
       
       // Function to calculate placement for new user when both referrer and new user are provided
       async function calculatePlacementForNewUser() {
         const newUserAddress = newUserInput.value.trim();
         const referrerAddress = referrerDisplay.getAttribute('data-full-address') || referrerDisplay.value.trim();
         
         // Only calculate if both addresses are valid and different
         if (!newUserAddress || !referrerAddress || 
             !/^0x[a-fA-F0-9]{40}$/.test(newUserAddress) || 
             !/^0x[a-fA-F0-9]{40}$/.test(referrerAddress) ||
             newUserAddress.toLowerCase() === referrerAddress.toLowerCase()) {
           return;
         }
         
         try {
           if (!window.contractConfig || !window.contractConfig.contract) return;
           const contract = window.contractConfig.contract;
           
           // Get current user info
           let myAddress = null;
           let myUser = null;
           try {
             if (window.currentUserAddress) {
               myAddress = window.currentUserAddress;
               myUser = await contract.users(myAddress);
             } else {
               myAddress = contract.signer ? await contract.signer.getAddress() : null;
               if (myAddress) {
                 myUser = await contract.users(myAddress);
                 window.currentUserAddress = myAddress;
               }
             }
           } catch (e) {
             console.log('Error getting current user:', e);
             return;
           }
           
           // Only show placement if current user is active
           if (!myUser || !(myUser.index && BigInt(myUser.index) > 0n)) {
             return;
           }
           
           
         } catch (error) {
           console.error('Error calculating placement for new user:', error);
         }
       }
      


                             // Register new user (based on selected type)
    document.getElementById('register-btn').onclick = async function() {
      const status = document.getElementById('status-message');
      const registerBtn = this;
      
      // Disable button and show loading state
      registerBtn.disabled = true;
      registerBtn.style.opacity = '0.6';
      status.style.color = '#1976d2';
      status.textContent = 'Connecting wallet...';
      
      try {
        // Check if MetaMask is installed
        if (!window.ethereum) {
          status.style.color = '#ff6b6b';
          status.textContent = '❌ MetaMask not detected. Please install MetaMask extension first.';
          registerBtn.disabled = false;
          registerBtn.style.opacity = '1';
          return;
        }
        
        // Ensure wallet connection and get contract instance
        let contract = null, signerAddress = null;
        let connectionError = null;
        
        // Try to connect wallet first
        status.textContent = 'Requesting wallet connection...';
        try {
          if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            if (conn && conn.contract) {
              contract = conn.contract;
              signerAddress = conn.address || (conn.signer ? await conn.signer.getAddress() : null);
              console.log('✅ Wallet connected via connectWallet:', signerAddress);
            } else {
              console.warn('⚠️ connectWallet returned but no contract found');
            }
          } else {
            console.warn('⚠️ connectWallet function not available');
          }
          
          // Fallback to cached connection
          if (!contract && window.contractConfig && window.contractConfig.contract) {
            contract = window.contractConfig.contract;
            signerAddress = window.contractConfig.address;
            console.log('✅ Using cached contract connection:', signerAddress);
          }
        } catch (error) {
          connectionError = error;
          console.error('❌ Wallet connection error:', error);
        }
        
        if (!contract) {
          status.style.color = '#ff6b6b';
          let errorMsg = '❌ Wallet connection failed. Please try again.';
          if (connectionError) {
            if (connectionError.code === 4001) {
              errorMsg = '❌ Wallet connection was rejected. Please try again and approve the connection in MetaMask.';
            } else if (connectionError.message) {
              errorMsg = '❌ Wallet connection failed: ' + connectionError.message;
            }
          }
          status.textContent = errorMsg;
          registerBtn.disabled = false;
          registerBtn.style.opacity = '1';
          // Show retry section if wallet connection failed
          const retrySection = document.getElementById('wallet-retry-section');
          if (retrySection) {
            retrySection.style.display = 'block';
          }
          return;
        }
        
        // Update status - wallet connected
        status.textContent = '✅ Wallet connected. Validating information...';

        // Get full addresses for registration (not truncated display)
        const referrer = referrerDisplay.getAttribute('data-full-address') || referrerDisplay.value.trim();
        const upper = upperInput.getAttribute('data-full-address') || upperInput.value.trim();
        const newUser = newUserInput.value.trim();
        
        // Validate inputs
        if (!/^0x[a-fA-F0-9]{40}$/.test(referrer)) throw new Error('Invalid referrer address. Please enter a valid address.');
        if (currentRegistrationType === 'normal' && !/^0x[a-fA-F0-9]{40}$/.test(upper)) throw new Error('Invalid upper address. Please enter a valid address.');
        if (!/^0x[a-fA-F0-9]{40}$/.test(newUser)) throw new Error('Invalid new wallet address. Please enter a valid address.');
        
        
        // Check if current user can register for referrer and upper
        const canRegisterForReferrer = await canUserRegisterForAddress(referrer, 'referrer');
        if (!canRegisterForReferrer) {
          throw new Error('You can only register for yourself or your downlines. This referrer is not in your downline.');
        }
        
        if (currentRegistrationType === 'normal') {
          const canRegisterForUpper = await canUserRegisterForAddress(upper, 'upper');
          if (!canRegisterForUpper) {
            throw new Error('You can only register for yourself or your downlines. This upper address is not in your downline.');
          }
          await validateReferrerUpperRelationship(contract, referrer, upper);
        }
        let myAddress = null, user = null;
        const sameAddress = (a, b) => {
          if (!a || !b) return false;
          try { return a.toLowerCase() === b.toLowerCase(); } catch(_) { return false; }
        };
                 try {
             // استفاده از آدرس ذخیره شده
          // Determine connected wallet address robustly
          myAddress = (window.ethereum && window.ethereum.selectedAddress) ? window.ethereum.selectedAddress : null;
          if (!myAddress && contract.signer) {
            try { myAddress = await contract.signer.getAddress(); } catch(_) {}
          }
          if (!myAddress && window.contractConfig && window.contractConfig.address) {
            myAddress = window.contractConfig.address;
          }
          if (myAddress) {
            user = await contract.users(myAddress);
            window.currentUserAddress = myAddress;
          }
         } catch (e) {
             console.log(`Error getting user info in reserve registration:`, e);
           }
          
                     console.log(`🔍 Checking user in reserve registration:`, user);
                   // Check if user is registering for themselves or others
          // Support both 'index' (old) and 'num' (new contract) field names
          const userNum = user && (user.num !== undefined ? user.num : (user.index !== undefined ? user.index : undefined));
          if (userNum && BigInt(userNum) > 0n) {
             // User is active, can register others
             console.log(`✅ User is active, can register others`);
           } else {
             // If user is not active, check if they're registering for themselves
            if (sameAddress(newUser, myAddress)) {
               console.log(`✅ User registering for themselves`);
               // Allow self-registration
             } else {
               console.log(`⚠️ User not active:`, user);
               throw new Error(`You must register first to be able to register others.`);
             }
           }
         
                   // Check token balance based on registration type
         const userBalance = await contract.balanceOf(myAddress);
         let requiredAmount;
         
                    if (currentRegistrationType === 'free') {
             // Reserve mode: equivalent to $23 tokens
             let tokenPriceNum = 1; // Default price $1
             try {
               if (typeof contract.getTokenPrice === 'function') {
                 const tokenPrice = await contract.getTokenPrice();
                 tokenPriceNum = Number(ethers.formatUnits(tokenPrice, 18));
               }
             } catch (e) {
               console.log('Error getting token price, using default price:', e);
             }
             
             // Calculate required amount (23 USD / token price)
             const requiredAmountFloat = 23 / tokenPriceNum;
             requiredAmount = ethers.parseEther(requiredAmountFloat.toString());
          } else {
            // Normal mode: use safe regPrice function
            try {
              const regPrice = await (window.safeGetRegPrice ? window.safeGetRegPrice(contract) : null);
              if (regPrice) {
                requiredAmount = regPrice;
              } else {
                throw new Error('RegPrice not available');
              }
            } catch (e) {
              console.log('Error getting regPrice:', e);
              throw new Error('Unable to get registration price');
            }
         }
         
         if (userBalance < requiredAmount) {
           const requiredFormatted = Number(ethers.formatEther(requiredAmount)).toFixed(2);
           const currentFormatted = Number(ethers.formatEther(userBalance)).toFixed(2);
           throw new Error(`Insufficient IAM balance. Required: ${requiredFormatted} IAM, Current: ${currentFormatted} IAM`);
         }
         
                  showTempMessage(currentRegistrationType === 'free' ? 'Sending reserve registration request to network... Please wait for transaction confirmation.' : 'Sending normal registration request to network... Please wait for transaction confirmation.', 'info');
          localStorage.setItem('avatar_' + newUser, selectedAvatar);
          
                   // Select function based on registration type
        let tx;
        // Always use registerAndActivate; for reserve mode, use current user as upper
        if (currentRegistrationType === 'free') {
          const effectiveUpper = (upper && /^0x[a-fA-F0-9]{40}$/.test(upper)) ? upper : referrer;
          tx = await contract.registerAndActivate(referrer, effectiveUpper, newUser);
        } else {
          // For registerAndActivate, we need 3 parameters: referrer, upper, newUser
          tx = await contract.registerAndActivate(referrer, upper, newUser);
        }
          
         showTempMessage('Waiting for network transaction confirmation...', 'info');
          await tx.wait();
        showMessageBox('Registration completed successfully! Welcome to IAM family.', 'success');
        setTimeout(loadRegisterInfo, 1500);
      } catch (e) {
        let errorMsg = e && (e.reason || (e.revert && e.revert.args && e.revert.args[0]) || e.message || e);
        if (typeof errorMsg !== 'string') errorMsg = JSON.stringify(errorMsg);
        if (/already registered|Already registered/i.test(errorMsg)) {
          showTempMessage('This address is already registered.', 'error');
                   } else if (/not active|inactive/i.test(errorMsg)) {
          showTempMessage('Selected referrer is not active. Please enter an active referrer.', 'error');
        } else if (/invalid referrer|referrer/i.test(errorMsg)) {
           showTempMessage('Invalid referrer address or does not exist.', 'error');
                   } else if (/insufficient|balance/i.test(errorMsg)) {
              // Show guide message with link to swap page
             const shortage = errorMsg.match(/Required: ([\d.]+)|need ([\d.]+)/i);
             const shortageAmount = shortage ? (shortage[1] || shortage[2]) : '';
             showBuyIamGuide(shortageAmount);
                   } else if (/user rejected|reject/i.test(errorMsg)) {
          showTempMessage('Registration process was cancelled by you.', 'error');
        } else if (/execution reverted/i.test(errorMsg)) {
          const match = errorMsg.match(/reverted: "([^"]+)"/);
          if (match && match[1]) {
            showTempMessage('Error: ' + match[1], 'error');
          } else {
             showTempMessage('Transaction was reverted by contract. Please check inputs.', 'error');
          }
        } else {
          showMessageBox('❌ Registration error: ' + (errorMsg.length > 120 ? errorMsg.slice(0,120)+'...' : errorMsg), 'error');
        }
      } finally {
        // Restore button state
        registerBtn.disabled = false;
        registerBtn.style.opacity = '1';
      }
    };

     

    // Index input event listeners are now set up in setupEventListeners function
    
    // Quick Swap: DAI to IAM functionality
    (async function() {
      const daiInput = document.getElementById('quick-swap-dai-amount');
      const estimatedIamEl = document.getElementById('quick-swap-estimated-iam');
      const daiBalanceEl = document.getElementById('quick-swap-dai-balance');
      const swapBtn = document.getElementById('quick-swap-btn');
      const statusEl = document.getElementById('quick-swap-status');
      
      if (!daiInput || !swapBtn) return;
      
      let tokenPrice = null;
      let daiContract = null;
      let iamContract = null;
      let signer = null;
      let userAddress = null;
      
      // Initialize contracts and get token price
      async function initializeSwap() {
        try {
          if (!window.ethereum) {
            statusEl.textContent = 'Please connect MetaMask';
            statusEl.style.color = '#e74c3c';
            return false;
          }
          
          // Check ethers version and use appropriate provider
          let provider, signerInstance;
          if (ethers.BrowserProvider) {
            // ethers v6
            provider = new ethers.BrowserProvider(window.ethereum);
            signerInstance = await provider.getSigner();
            userAddress = await signerInstance.getAddress();
          } else if (ethers.providers && ethers.providers.Web3Provider) {
            // ethers v5
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signerInstance = provider.getSigner();
            userAddress = await signerInstance.getAddress();
          } else {
            throw new Error('Ethers.js not properly loaded');
          }
          signer = signerInstance;
          
          // Get contract instance
          let contract = null;
          if (window.contractConfig && window.contractConfig.contract) {
            contract = window.contractConfig.contract;
            iamContract = contract;
          } else if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            contract = conn && conn.contract ? conn.contract : null;
            iamContract = contract;
          }
          
          if (!iamContract) {
            statusEl.textContent = 'Contract not available. Please connect wallet.';
            statusEl.style.color = '#e74c3c';
            return false;
          }
          
          // Get token price
          if (typeof iamContract.getTokenPrice === 'function') {
            const price = await iamContract.getTokenPrice();
            // Support both ethers v5 and v6
            if (ethers.formatUnits) {
              tokenPrice = parseFloat(ethers.formatUnits(price, 18));
            } else {
              tokenPrice = parseFloat(ethers.utils.formatUnits(price, 18));
            }
          }
          
          // Initialize DAI contract
          const DAI_ADDRESS = window.DAI_ADDRESS || '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063';
          const DAI_ABI = [
            "function balanceOf(address) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
          ];
          
          daiContract = new ethers.Contract(DAI_ADDRESS, DAI_ABI, signer);
          
          // Load DAI balance
          await updateDaiBalance();
          
          // Auto-fill Quick Swap DAI field with required amount (no buffer)
          if (typeof autoFillQuickSwapDai === 'function') {
            await autoFillQuickSwapDai();
          }
          
          return true;
        } catch (e) {
          console.error('Error initializing swap:', e);
          if (statusEl) {
            statusEl.textContent = 'Error initializing: ' + (e.message || e);
            statusEl.style.color = '#e74c3c';
          }
          return false;
        }
      }
      
      // Update DAI balance display
      async function updateDaiBalance() {
        try {
          if (!daiContract || !userAddress) return;
          const balance = await daiContract.balanceOf(userAddress);
          // Support both ethers v5 and v6
          const balanceFormatted = ethers.formatUnits 
            ? parseFloat(ethers.formatUnits(balance, 18)).toFixed(2)
            : parseFloat(ethers.utils.formatUnits(balance, 18)).toFixed(2);
          if (daiBalanceEl) daiBalanceEl.textContent = balanceFormatted + ' DAI';
        } catch (e) {
          console.error('Error updating DAI balance:', e);
        }
      }
      
      // Calculate estimated IAM from DAI amount
      function calculateEstimatedIam(daiAmount) {
        if (!daiAmount || daiAmount <= 0 || !tokenPrice || tokenPrice <= 0) {
          return '0.00';
        }
        const estimatedIam = daiAmount / tokenPrice;
        return estimatedIam.toFixed(6);
      }
      
      // Update estimated IAM on input change
      daiInput.addEventListener('input', function() {
        const daiAmount = parseFloat(this.value) || 0;
        const estimatedIam = calculateEstimatedIam(daiAmount);
        if (estimatedIamEl) estimatedIamEl.textContent = estimatedIam;
        // Mark as user-edited to prevent auto-fill override
        this.dataset.userEdited = 'true';
      });
      
      // Swap button click handler
      swapBtn.addEventListener('click', async function() {
        const daiAmount = parseFloat(daiInput.value) || 0;
        
        if (daiAmount <= 0) {
          statusEl.textContent = 'Please enter a valid DAI amount';
          statusEl.style.color = '#e74c3c';
          return;
        }
        
        if (!await initializeSwap()) {
          return;
        }
        
        // Check DAI balance
        try {
          const balance = await daiContract.balanceOf(userAddress);
          // Support both ethers v5 and v6
          const balanceFormatted = ethers.formatUnits
            ? parseFloat(ethers.formatUnits(balance, 18))
            : parseFloat(ethers.utils.formatUnits(balance, 18));
          
          if (balanceFormatted < daiAmount) {
            statusEl.textContent = `Insufficient DAI balance. You have ${balanceFormatted.toFixed(4)} DAI.`;
            statusEl.style.color = '#e74c3c';
            return;
          }
        } catch (e) {
          statusEl.textContent = 'Error checking balance: ' + (e.message || e);
          statusEl.style.color = '#e74c3c';
          return;
        }
        
        // Disable button and show processing
        swapBtn.disabled = true;
        swapBtn.textContent = '⏳ Processing...';
        statusEl.textContent = 'Starting swap transaction...';
        statusEl.style.color = '#5da0ff';
        
        try {
          const IAM_ADDRESS = window.IAM_ADDRESS || iamContract.address;
          // Support both ethers v5 and v6
          const daiAmountWei = ethers.parseUnits
            ? ethers.parseUnits(daiAmount.toString(), 18)
            : ethers.utils.parseUnits(daiAmount.toString(), 18);
          
          // Check and approve DAI if needed
          const allowance = await daiContract.allowance(userAddress, IAM_ADDRESS);
          // Support both ethers v5 and v6 comparison
          const needsApproval = allowance && typeof allowance.lt === 'function' 
            ? allowance.lt(daiAmountWei)
            : BigInt(allowance) < BigInt(daiAmountWei);
          
          if (needsApproval) {
            statusEl.textContent = 'Approving DAI... Please confirm transaction.';
            const maxUint = ethers.MaxUint256 || ethers.constants.MaxUint256;
            const approveTx = await daiContract.approve(IAM_ADDRESS, maxUint);
            await approveTx.wait();
            statusEl.textContent = 'DAI approved. Executing swap...';
          }
          
          // Execute swap
          statusEl.textContent = 'Executing swap transaction... Please confirm.';
          const tx = await iamContract.buyTokens(daiAmountWei);
          statusEl.textContent = 'Transaction submitted. Waiting for confirmation...';
          
          await tx.wait();
          
          // Success
          statusEl.textContent = '✅ Swap successful! Your IAM balance has been updated.';
          statusEl.style.color = '#00ff88';
          
          // Update balances
          await updateDaiBalance();
          if (typeof refreshBuyCardBalances === 'function') {
            setTimeout(refreshBuyCardBalances, 2000);
          }
          
          // Clear input
          daiInput.value = '';
          if (estimatedIamEl) estimatedIamEl.textContent = '0.00';
          
        } catch (e) {
          let errorMsg = 'Swap failed: ' + (e.message || e);
          if (e.code === 4001 || (e.message && e.message.includes('user denied'))) {
            errorMsg = 'Transaction cancelled by user.';
          } else if (e.code === -32002) {
            errorMsg = 'MetaMask is processing a previous request. Please wait.';
          }
          statusEl.textContent = errorMsg;
          statusEl.style.color = '#e74c3c';
        } finally {
          swapBtn.disabled = false;
          swapBtn.textContent = '🔄 Swap DAI to IAM';
        }
      });
      
      // Initialize on load
      setTimeout(async () => {
        await initializeSwap();
      }, 1000);
    })();
  </script>
  
  
</body>
</html> 
</html> 