<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Price Charts | PHOENIX (IAM)</title>
  
  <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
  
  <!-- Load ethers.js version 6 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.umd.min.js"></script>
  
  <!-- Main scripts (index.js removed for browser compatibility) -->
  <script src="js/config.js"></script>
  <script src="js/auto-wallet-connect.js"></script>
  
  
  <style>
    body {
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d3748 100%);
      color: #e2e8f0;
      font-family: 'Noto Sans Arabic', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    
    .back-btn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      color: #181c2a;
      text-decoration: none;
      padding: 0.7rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(167, 134, 255, 0.3);
    }
    
    .back-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(167, 134, 255, 0.4);
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      padding-top: 4rem;
    }
    
    .page-header {
      text-align: center;
      margin-bottom: 3rem;
    }
    
    .page-title {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }
    
    .page-subtitle {
      font-size: 1.1rem;
      color: #94a3b8;
      margin-bottom: 2rem;
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    
    @media (max-width: 768px) {
    .charts-grid {
      grid-template-columns: 1fr;
        gap: 1.5rem;
      }
    }
    
    .chart-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 1.5rem;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .chart-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.3rem;
      font-weight: 600;
      color: #e2e8f0;
      margin: 0;
    }
    
    .chart-icon {
      font-size: 1.5rem;
    }
    
    .chart-stats {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }
    
    .stat-item {
      text-align: center;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #00ff88;
      margin-bottom: 0.25rem;
    }
    
    .stat-label {
      font-size: 0.8rem;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
    }
    
    .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Token chart specific styling for low prices */
    #tokenChart {
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 136, 0.02) 100%);
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
    
    /* Point chart specific styling */
    #pointChart {
      background: linear-gradient(135deg, rgba(167, 134, 255, 0.05) 0%, rgba(167, 134, 255, 0.02) 100%);
      border-radius: 8px;
      border: 1px solid rgba(167, 134, 255, 0.2);
    }
    
    /* Chart tooltip styling */
    .chartjs-tooltip {
      background: rgba(0, 0, 0, 0.9) !important;
      border: 1px solid #00ff88 !important;
      border-radius: 6px !important;
      box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3) !important;
    }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.1rem;
      color: #94a3b8;
    }
    
    .error {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #ff6b6b;
      text-align: center;
      flex-direction: column;
      gap: 1rem;
    }
    
    .error-icon {
      font-size: 3rem;
    }
    
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }
    
    .status-online {
      background: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }
    
    .status-offline {
      background: #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
    }
    
    .status-warning {
      background: #ffa726;
      box-shadow: 0 0 10px rgba(255, 167, 38, 0.5);
    }
  </style>
</head>

<body>
  <a href="index.html" class="back-btn">‚Üê Back to Home</a>
  
  <div class="container">
    <div class="page-header">
      <h1 class="page-title">Price Charts</h1>
      <p class="page-subtitle">Real-time IAM Token and Point Price Analysis</p>
    </div>

    
    <div class="charts-grid">
      <!-- Point Price Chart -->
      <div class="chart-card">
        <div class="chart-header">
          <h3 class="chart-title">
            <span class="chart-icon">‚≠ê</span>
            Point Price Chart
          </h3>
          <div class="chart-stats" id="pointStats">
            <div class="stat-item">
              <div class="stat-value current-price" id="currentPointPrice">$0.00</div>
              <div class="stat-label">Current Price</div>
            </div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="pointChart"></canvas>
        </div>
      </div>

      <!-- Token Price Chart -->
      <div class="chart-card">
        <div class="chart-header">
          <h3 class="chart-title">
            <span class="chart-icon">üí∞</span>
            Token Price Chart
          </h3>
          <div class="chart-stats" id="tokenStats">
            <div class="stat-item">
              <div class="stat-value current-price" id="currentTokenPrice">Loading...</div>
              <div class="stat-label">Current Price</div>
            </div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="tokenChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Global variables
  let tokenChart = null;
  let pointChart = null;
    
    // Define functions before they're used
  // Auto-refresh removed: charts update live via on-chain events only

    // Load token chart from database
    async function loadTokenChartFromDatabase() {
      try {
        console.log('üîÑ Loading token chart from database...');
        const tokenCanvas = document.getElementById('tokenChart');
        
            // First try to load from localStorage (historical blockchain data)
            const localStorageHistory = window.getTokenHistoryFromStorage();
        console.log('üìä localStorage history length:', localStorageHistory ? localStorageHistory.length : 0);
        
        if (localStorageHistory && localStorageHistory.length > 0) {
          console.log(`üìä Using ${localStorageHistory.length} historical prices from localStorage`);
          console.log('üìä First few prices:', localStorageHistory.slice(0, 3).map(p => ({
            price: p.price.toExponential(6),
            timestamp: p.timestamp
          })));
          
          // Convert localStorage format to chart format
          const chartData = localStorageHistory.map(item => ({
            created_at: item.timestamp,
            price_usd: item.price.toString(),
            symbol: 'IAM',
            name: 'IAM Token'
          }));
          
          // Update stats with latest data
          const latestToken = chartData[chartData.length - 1];
          updateTokenStats(latestToken);
          
          await createTokenChart(tokenCanvas, chartData);
          console.log('‚úÖ Token chart loaded from localStorage with', chartData.length, 'records');
          return;
        } else {
          console.warn('‚ö†Ô∏è No historical data in localStorage, checking raw localStorage...');
          const rawData = localStorage.getItem('token_price_history');
          console.log('üìä Raw localStorage data:', rawData ? JSON.parse(rawData).length : 0, 'items');
        }
        
        // No API: if nothing in storage, draw empty chart
        await createTokenChart(tokenCanvas, []);
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not load token chart, using fallback:', error.message);
        const tokenCanvas = document.getElementById('tokenChart');
        await createTokenChart(tokenCanvas, []);
      }
    }
    
    // Load point chart from database
    async function loadPointChartFromDatabase() {
      try {
        console.log('üîÑ Loading point chart from database...');
        const pointCanvas = document.getElementById('pointChart');
        
            // First try to load from localStorage (historical blockchain data)
            const pointHistory = window.getPointHistoryFromStorage();
        if (pointHistory && pointHistory.length > 0) {
          console.log(`üìä Using ${pointHistory.length} historical point values from localStorage`);
          
          // Convert localStorage format to chart format
          const chartData = pointHistory.map(item => ({
            created_at: item.timestamp,
            point_value_usd: item.price.toString(),
            pointType: 'binary_points'
          }));
          
          // Update stats with latest data
          const latestPoint = chartData[chartData.length - 1];
          updatePointStats(latestPoint);
          
          await createPointChart(pointCanvas, chartData);
          console.log('‚úÖ Point chart loaded from localStorage with', chartData.length, 'records');
          return;
        }
        
        // No API: if nothing in storage, draw empty chart
        await createPointChart(pointCanvas, []);
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not load point chart, using fallback:', error.message);
        const pointCanvas = document.getElementById('pointChart');
        await createPointChart(pointCanvas, []);
      }
    }


    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üöÄ Initializing Price Charts...');
      console.log('üìä Chart.js available:', typeof Chart !== 'undefined');
      
      // Check if Chart.js is loaded
      if (typeof Chart === 'undefined') {
        console.error('‚ùå Chart.js not loaded! Please check your internet connection.');
        showError('Chart.js library not loaded. Please check your internet connection.');
        return;
      }
      
      
      // Auto test charts after 2 seconds
      setTimeout(() => {
        console.log('üîÑ Loading real data...');
      }, 2000);
      
      try {
        // Load historical data directly from blockchain
        if (window.ethereum && window.IAM_ABI) {
          console.log('üîÑ Loading historical data first...');
          const provider = new ethers.BrowserProvider(window.ethereum);
          const address = (typeof window.getIAMAddress === 'function') ? window.getIAMAddress() : (window.IAM_ADDRESS || '0xa4C37107AbaeD664978e5f6db79249Ad08Fe0dBf');
          if (address) {
            await seedInitialAndCurrentTokenHistory(provider, address).catch(()=>{});
            await loadHistoricalPriceData(provider, address);
            await setupDirectEventListeners();
          }
        }
        
        // Load charts from local history (seed + backfilled events)
        await loadTokenChartFromDatabase();
        await loadPointChartFromDatabase();
        console.log('‚úÖ Price Charts initialized (contract-only mode)');
      } catch (error) {
        console.error('‚ùå Error initializing Price Charts:', error);
        // Minimal fallback: render with whatever is in localStorage
        await loadTokenChartFromDatabase().catch(()=>{});
        await loadPointChartFromDatabase().catch(()=>{});
      }
    });

    // Attach direct on-chain event listeners to build history and live-update charts
    async function setupDirectEventListeners() {
      if (!window.ethereum || !window.IAM_ABI) {
        console.warn('‚ö†Ô∏è ethereum or ABI not available for direct listeners');
        return;
      }
      try {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const address = (typeof window.getIAMAddress === 'function') ? window.getIAMAddress() : (window.IAM_ADDRESS || '0xa4C37107AbaeD664978e5f6db79249Ad08Fe0dBf');
        if (!address) {
          console.warn('‚ö†Ô∏è No IAM address available');
          return;
        }
        const contract = new ethers.Contract(address, window.IAM_ABI, await provider.getSigner());

        // First, ensure seed is present, then load historical data
        await seedInitialAndCurrentTokenHistory(provider, address).catch(()=>{});
        await loadHistoricalPriceData(provider, address);

        const handleTokenUpdate = async (newPrice, daiBalance, tokenSupply, ts) => {
          try {
            const priceUsd = Number(ethers.formatUnits(newPrice, 18));
            // Save to local history and update UI immediately
            saveTokenPriceToHistory(priceUsd);
            updateTokenStats({ price_usd: priceUsd });
            // Re-render chart from local history
            await loadTokenChartFromDatabase();
          } catch (e) {
            console.warn('‚ö†Ô∏è TokenPriceUpdated handler failed:', e?.message || e);
          }
        };

        const handlePointUpdate = async (newPointValue, totalClaimable, contractTokenBalance, ts) => {
          try {
            const pointUsd = Number(ethers.formatUnits(newPointValue, 18));
            // Save to local history and update UI immediately
            savePointValueToHistory(pointUsd);
            updatePointStats({ point_value_usd: pointUsd });
            // Re-render chart from local history
            await loadPointChartFromDatabase();
          } catch (e) {
            console.warn('‚ö†Ô∏è PointValueUpdated handler failed:', e?.message || e);
          }
        };

        // Direct price events
        contract.on('TokenPriceUpdated', handleTokenUpdate);
        contract.on('PointValueUpdated', handlePointUpdate);

        // Trigger events that may affect price/points
        const triggers = ['TokensBought','TokensSold','PurchaseKind','BinaryPoolUpdated','Activated','UserRegistered','BinaryPointsClaimed'];
        for (const ev of triggers) {
          contract.on(ev, async () => {
            try {
              await Promise.all([
                loadTokenChartFromDatabase().catch(()=>{}),
                loadPointChartFromDatabase().catch(()=>{})
              ]);
            } catch (e) {
              console.warn(`‚ö†Ô∏è Trigger handler failed for ${ev}:`, e?.message || e);
            }
          });
        }

        console.log('‚úÖ Direct contract event listeners attached for charts');
      } catch (error) {
        console.warn('‚ö†Ô∏è setupDirectEventListeners error:', error?.message || error);
      }
    }

    // Load historical price data from blockchain events
    async function loadHistoricalPriceData(provider, contractAddress) {
      try {
        console.log('üîÑ Loading historical price data from blockchain...');
        console.log('üìä Contract address:', contractAddress);
        console.log('üìä ABI available:', !!window.IAM_ABI);
        
        const iface = new ethers.Interface(window.IAM_ABI);
        const currentBlock = await provider.getBlockNumber();
        
        // Get events from last 7 days (approximately 45000 blocks on Polygon)
        const fromBlock = Math.max(currentBlock - 45000, 0);
        
        console.log(`üìä Fetching events from block ${fromBlock} to ${currentBlock} (${currentBlock - fromBlock} blocks)`);
        
        // Get TokenPriceUpdated events
        const tokenPriceTopic = iface.getEvent('TokenPriceUpdated').topicHash;
        console.log('üìä TokenPriceUpdated topic hash:', tokenPriceTopic);
        
        const tokenPriceLogs = await provider.getLogs({
          address: contractAddress,
          fromBlock: fromBlock,
          toBlock: currentBlock,
          topics: [tokenPriceTopic]
        });
        
        console.log(`üìä Found ${tokenPriceLogs.length} TokenPriceUpdated events`);
        
            // Process token price events
            const tokenPriceHistory = [];
            for (const log of tokenPriceLogs) {
              try {
                const { args } = iface.parseLog(log);
                const priceUsd = Number(ethers.formatUnits(args[0], 18));
                const timestamp = Number(args[3]) * 1000; // Convert to milliseconds
                
                tokenPriceHistory.push({
                  price: priceUsd,
                  timestamp: new Date(timestamp).toISOString(),
                  blockNumber: log.blockNumber
                });
                
                console.log(`üìä Token price event: ${priceUsd.toExponential(6)} USD at ${new Date(timestamp).toLocaleString()}`);
              } catch (e) {
                console.warn('‚ö†Ô∏è Failed to decode TokenPriceUpdated event:', e);
              }
            }
        
        // Sort and merge with existing seed (initial/current) then save
        tokenPriceHistory.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        if (tokenPriceHistory.length > 0) {
          // Convert to storage format
          const storageItems = tokenPriceHistory.map(ev => ({ price: ev.price, timestamp: ev.timestamp }));
          mergeAndSaveTokenHistory(storageItems);
          console.log(`‚úÖ Merged ${tokenPriceHistory.length} historical token prices into localStorage`);
          console.log('üìä Price range:', {
            min: Math.min(...tokenPriceHistory.map(p => p.price)).toExponential(6),
            max: Math.max(...tokenPriceHistory.map(p => p.price)).toExponential(6),
            first: tokenPriceHistory[0].price.toExponential(6),
            last: tokenPriceHistory[tokenPriceHistory.length - 1].price.toExponential(6)
          });
        } else {
          console.warn('‚ö†Ô∏è No TokenPriceUpdated events found in the specified block range');
        }
        
        // Get PointValueUpdated events
        const pointValueTopic = iface.getEvent('PointValueUpdated').topicHash;
        console.log('üìä PointValueUpdated topic hash:', pointValueTopic);
        
        const pointValueLogs = await provider.getLogs({
          address: contractAddress,
          fromBlock: fromBlock,
          toBlock: currentBlock,
          topics: [pointValueTopic]
        });
        
        console.log(`üìä Found ${pointValueLogs.length} PointValueUpdated events`);
        
            // Process point value events
            const pointValueHistory = [];
            for (const log of pointValueLogs) {
              try {
                const { args } = iface.parseLog(log);
                const pointValueUsd = Number(ethers.formatUnits(args[0], 18));
                const timestamp = Number(args[3]) * 1000; // Convert to milliseconds
                
                pointValueHistory.push({
                  price: pointValueUsd,
                  timestamp: new Date(timestamp).toISOString(),
                  blockNumber: log.blockNumber
                });
                
                console.log(`üìä Point value event: $${pointValueUsd.toFixed(2)} USD at ${new Date(timestamp).toLocaleString()}`);
              } catch (e) {
                console.warn('‚ö†Ô∏è Failed to decode PointValueUpdated event:', e);
              }
            }
        
        // Sort by timestamp
        pointValueHistory.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Save to localStorage for chart display
        if (pointValueHistory.length > 0) {
          localStorage.setItem('point_value_history', JSON.stringify(pointValueHistory));
          console.log(`‚úÖ Saved ${pointValueHistory.length} historical point values to localStorage`);
          console.log('üìä Point value range:', {
            min: Math.min(...pointValueHistory.map(p => p.price)).toFixed(2),
            max: Math.max(...pointValueHistory.map(p => p.price)).toFixed(2),
            first: pointValueHistory[0].price.toFixed(2),
            last: pointValueHistory[pointValueHistory.length - 1].price.toFixed(2)
          });
        } else {
          console.warn('‚ö†Ô∏è No PointValueUpdated events found in the specified block range');
        }
        
        console.log('‚úÖ Historical data loaded successfully');
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to load historical data:', error?.message || error);
        console.error('Full error:', error);
      }
    }
    
    // Fallback function for when API is not available
    // Fallback mode removed (contract-only)

    // Load charts with real data
    // loadCharts removed (we call specific loaders directly)
    
    // Load token chart
    async function loadTokenChart() {
      try {
        console.log('üîÑ Loading token chart...');
        
        const canvas = document.getElementById('tokenChart');
        if (!canvas) return;
        
        // Contract-only: draw from localStorage history
        const history = window.getTokenHistoryFromStorage().map(item => ({
          created_at: item.timestamp,
          price_usd: String(item.price)
        }));
        
        // Create chart
        await createTokenChart(canvas, history);
        
      } catch (error) {
        console.error('‚ùå Error loading token chart:', error);
        showChartError(document.getElementById('tokenChart'), 'Failed to load token chart');
      }
    }
    
    // Load point chart
    async function loadPointChart() {
      try {
        console.log('üîÑ Loading point chart...');
        
        const canvas = document.getElementById('pointChart');
        if (!canvas) return;
        
        // Contract-only: draw from localStorage history
        const pointHistory = window.getPointHistoryFromStorage().map(item => ({
          created_at: item.timestamp,
          point_value_usd: String(item.price)
        }));
        
        // Create chart
        await createPointChart(canvas, pointHistory);
        
      } catch (error) {
        console.error('‚ùå Error loading point chart:', error);
        showChartError(document.getElementById('pointChart'), 'Failed to load point chart: ' + error.message);
      }
    }
    
    // Get prices from floating-token-card
    async function getPricesFromFloatingCard() {
      try {
        // Check if floating token card exists
        if (window.floatingTokenGrowthCard && typeof window.floatingTokenGrowthCard.getTokenGrowthData === 'function') {
          const data = await window.floatingTokenGrowthCard.getTokenGrowthData();
          console.log('üìä Prices from floating-token-card:', data);
          return data;
        }
        
        // Fallback: try to get from priceHistoryManager
        if (window.priceHistoryManager && window.priceHistoryManager.tokenHistory.length > 0) {
          const tokenHistory = window.priceHistoryManager.tokenHistory;
          const currentPrice = tokenHistory[tokenHistory.length - 1];
          const initialPrice = 1e-15; // Default from floating-token-card
          
          return {
            currentPrice: currentPrice,
            initialPrice: initialPrice,
            growthPercentage: ((currentPrice - initialPrice) / initialPrice) * 100,
            source: 'priceHistoryManager'
          };
        }
        
        return null;
      } catch (error) {
        console.error('‚ùå Error getting prices from floating-token-card:', error);
        return null;
      }
    }

    // Removed Neon-related save function

    // Global variables for price comparison
    let lastTokenPrice = null;
    let lastPointPrice = null;
    let chartUpdateNeeded = false;

    // Update token stats with price comparison
    function updateTokenStats(priceData) {
      const priceElement = document.getElementById('currentTokenPrice');
      
      if (priceElement) {
        const price = parseFloat(priceData.price_usd || priceData.priceUsd || priceData.price || 0);
        if (isNaN(price) || price === 0) {
          priceElement.textContent = 'Loading...';
          console.warn('‚ö†Ô∏è Token price is 0 or invalid:', priceData);
        } else {
          priceElement.textContent = price.toExponential(2);
          console.log('üìä Token price updated:', price);
        }
      } else {
        console.warn('‚ö†Ô∏è Token price element not found');
      }
    }
    
    // Get prices from floating-token-card
    async function getPricesFromFloatingCard() {
      try {
        // Check if floating token card exists
        const floatingCard = document.querySelector('.floating-token-card');
        if (!floatingCard) {
          console.log('‚ö†Ô∏è Floating token card not found');
          return null;
        }
        
        // Get current price from floating card
        const priceElement = floatingCard.querySelector('.token-price');
        if (!priceElement) {
          console.log('‚ö†Ô∏è Price element not found in floating card');
          return null;
        }
        
        const priceText = priceElement.textContent;
        const currentPrice = parseFloat(priceText.replace(/[^\d.-]/g, ''));
        
        if (isNaN(currentPrice)) {
          console.log('‚ö†Ô∏è Invalid price in floating card:', priceText);
          return null;
        }
        
        console.log('üìä Current price from floating card:', currentPrice);
        return { currentPrice };
        
      } catch (error) {
        console.error('‚ùå Error getting prices from floating card:', error);
        return null;
      }
    }
    
    // Update token stats with price comparison
    function updateTokenStatsWithComparison(priceData) {
      const priceElement = document.getElementById('currentTokenPrice');
      
      if (priceElement) {
        const price = parseFloat(priceData.price_usd || priceData.priceUsd || 0);
        if (isNaN(price) || price === 0) {
          priceElement.textContent = 'Loading...';
          console.warn('‚ö†Ô∏è Token price is 0 or invalid:', priceData);
        } else {
          priceElement.textContent = price.toExponential(2);
          console.log('üìä Token price updated:', price);
        }
        
        // Get prices from floating-token-card for comparison
        getPricesFromFloatingCard().then(floatingData => {
          if (floatingData) {
            const currentPrice = floatingData.currentPrice;
            
            // Check if price has changed significantly (more than 0.1%)
            const priceChanged = !lastTokenPrice || 
              Math.abs(currentPrice - lastTokenPrice) / lastTokenPrice > 0.001;
            
            if (priceChanged) {
              console.log('üìä Price changed, updating chart:', {
                lastPrice: lastTokenPrice ? lastTokenPrice.toExponential(6) : 'None',
                currentPrice: currentPrice.toExponential(6),
                changePercent: lastTokenPrice ? 
                  ((currentPrice - lastTokenPrice) / lastTokenPrice * 100).toFixed(4) + '%' : 'N/A'
              });
              
              // Update last price
              lastTokenPrice = currentPrice;
              chartUpdateNeeded = true;
              
              console.log('üìä Token stats updated from floating-token-card:', {
                currentPrice: currentPrice.toExponential(6),
                chartUpdateNeeded: chartUpdateNeeded
              });
            } else {
              console.log('üìä Price unchanged, skipping chart update:', {
                currentPrice: currentPrice.toExponential(6),
                lastPrice: lastTokenPrice.toExponential(6)
                });
            }
          } else {
            console.log('‚ö†Ô∏è No floating data available, using contract data only');
          }
        }).catch(error => {
          console.error('‚ùå Error getting floating data:', error);
        });
      } else {
        console.warn('‚ö†Ô∏è Token price element not found');
      }
    }
    
    // Update point stats
    function updatePointStats(priceData) {
      const priceElement = document.getElementById('currentPointPrice');
      
      if (priceElement) {
        const price = parseFloat(priceData.point_value_usd || priceData.pointValueUsd || priceData.price || 0);
        if (isNaN(price) || price === 0) {
          priceElement.textContent = '$0.00';
          console.log('üìä Point price is 0 (real data from contract)');
        } else {
          priceElement.textContent = `$${price.toFixed(2)}`;
          console.log('üìä Point price updated:', price);
        }
      } else {
        console.warn('‚ö†Ô∏è Point price element not found');
      }
    }
    
    // Create token chart with sample data
    function createTokenChartWithSampleData(canvas) {
      console.log('üîÑ Creating token chart with sample data');
      
      if (tokenChart) {
        tokenChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }

      const ctx = canvas.getContext('2d');

      // Generate sample data for token price
      const labels = [];
      const prices = [];
      
      // Generate 24 hours of data
      for (let i = 23; i >= 0; i--) {
        const date = new Date();
        date.setHours(date.getHours() - i);
        labels.push(date.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit'
        }));
        
        // Generate realistic token price data (very small numbers)
        const basePrice = 1.28e-15;
        const variation = (Math.random() - 0.5) * 0.1e-15; // ¬±5% variation
        const price = basePrice + variation;
        prices.push(price);
      }

      const data = {
        labels: labels,
        datasets: [{
          label: 'Token Price (USD)',
          data: prices,
          borderColor: '#00ff88',
          backgroundColor: 'rgba(0, 255, 136, 0.1)',
          borderWidth: 2,
          fill: true,
          tension: 0.4,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointBackgroundColor: '#00ff88',
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2
        }]
      };

      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#00ff88',
              borderColor: '#00ff88',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  const value = parseFloat(context.raw);
                  return [
                    'Token Price: ' + value.toExponential(6),
                    'USD: $' + value.toExponential(3),
                    'Scientific: ' + value.toExponential(6)
                  ];
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Price (Scientific)',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                },
                callback: function(value) {
                  const val = parseFloat(value);
                  return val.toExponential(2);
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            }
          }
        }
      };

      try {
        tokenChart = new Chart(ctx, config);
        console.log('‚úÖ Token chart created with sample data');
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }

    // Create point chart with sample data
    function createPointChartWithSampleData(canvas) {
      console.log('üîÑ Creating point chart with sample data');
      
      if (pointChart) {
        pointChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      
      // Generate sample data for point price
      const labels = [];
      const prices = [];
      
      // Generate 24 hours of data
      for (let i = 23; i >= 0; i--) {
        const date = new Date();
        date.setHours(date.getHours() - i);
        labels.push(date.toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        }));
        
        // Generate realistic point price data
        const basePrice = 15.63;
        const variation = (Math.random() - 0.5) * 2; // ¬±$1 variation
        const price = basePrice + variation;
        prices.push(price);
      }
      
      const data = {
        labels: labels,
        datasets: [{
          label: 'Point Price (USD)',
          data: prices,
          borderColor: '#a786ff',
          backgroundColor: 'rgba(167, 134, 255, 0.1)',
          borderWidth: 2,
          fill: true,
          tension: 0.4,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointBackgroundColor: '#a786ff',
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2
        }]
      };
      
      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#a786ff',
              borderColor: '#a786ff',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  return '$' + parseFloat(context.raw).toFixed(2);
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Price (USD)',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                },
                callback: function(value) {
                  return '$' + parseFloat(value).toFixed(2);
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            }
          }
        }
      };
      
      try {
        pointChart = new Chart(ctx, config);
        console.log('‚úÖ Point chart created with sample data');
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }

    // Create token chart
    async function createTokenChart(canvas, history) {
      console.log('üîÑ Creating token chart with', history.length, 'data points');
      
      if (tokenChart) {
        tokenChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }

      const ctx = canvas.getContext('2d');

      // Use real data if available, otherwise generate sample data
      let labels = [];
      let prices = [];

      if (history && history.length > 0) {
        // Use real historical data from events
        labels = history.map(item => {
          const date = new Date(item.created_at);
          return date.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit' 
          });
        });
        prices = history.map(item => parseFloat(item.price_usd));
        console.log('üìä Using real historical data from events:', prices.length, 'data points');
      } else {
        // Try to get history from localStorage
        const tokenHistory = getTokenHistoryFromStorage();
        if (tokenHistory && tokenHistory.length > 0) {
          labels = tokenHistory.map(item => {
            const date = new Date(item.timestamp);
            return date.toLocaleTimeString('en-US', { 
              hour: '2-digit', 
              minute: '2-digit' 
            });
          });
          prices = tokenHistory.map(item => parseFloat(item.price));
          console.log('üìä Using token history from localStorage:', prices.length, 'data points');
        } else {
        // Get current price from getTokenPrice() and create history
        try {
          const currentPrice = await priceService.getRealTokenPrice();
          const currentPriceValue = parseFloat(currentPrice.price_usd);
          
          // Create 6 data points with current price
          labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
          prices = [currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue];
          
          console.log('üìä Using current price from getTokenPrice():', currentPriceValue);
          console.log('üìä Chart will update automatically on contract events (TokensBought, TokensSold, PurchaseKind, Activated, TokenPriceUpdated)');
        } catch (error) {
          console.warn('‚ö†Ô∏è Could not get current price, using fallback:', error.message);
          // Fallback to 1e-15
          labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
          prices = [1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15];
        }
      }

      // Calculate price range for better scaling
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const priceRange = maxPrice - minPrice;
      const centerPrice = (minPrice + maxPrice) / 2;

      console.log('üìä Token price range (real data):', {
        min: minPrice,
        max: maxPrice,
        range: priceRange,
        center: centerPrice,
        prices: prices,
        note: 'Using real contract data - token price is 1e-15',
        scientific: '1.000000e-15',
        chartRange: '1e-15 to 1.2e-15 (1000-1200 wei) for better visualization'
      });

      // If we have only one data point, create a range around it
      if (prices.length === 1) {
        const singlePrice = prices[0];
        const padding = singlePrice * 0.1; // 10% padding
        const adjustedMin = Math.max(0, singlePrice - padding);
        const adjustedMax = singlePrice + padding;
        
        console.log('üìä Single data point adjustment:', {
          original: singlePrice,
          adjustedMin: adjustedMin,
          adjustedMax: adjustedMax,
          note: 'Real contract price with 10% padding for better visualization'
        });
      }

      const data = {
          labels: labels,
          datasets: [{
          label: 'Token Price (USD) - Real Contract Data',
            data: prices,
            borderColor: '#00ff88',
            backgroundColor: 'rgba(0, 255, 136, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointRadius: 4,
          pointHoverRadius: 6,
          pointBackgroundColor: '#00ff88',
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2
        }]
      };

      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#00ff88',
              borderColor: '#00ff88',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                    const value = parseFloat(context.raw);
                    return [
                      'Real Token Price: ' + value.toExponential(6),
                      'USD: $' + value.toExponential(3),
                      'Scientific: ' + value.toExponential(6),
                      'Contract Data: 1e-15 (Real)',
                      'Percentage: ' + ((value / 1e-15) * 100).toFixed(2) + '% of 1e-15',
                      'Chart Range: 1e-15 to 1.2e-15 (1000-1200 wei)'
                    ];
                  },
                title: function(context) {
                  const date = new Date(context[0].label);
                  return date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                  });
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            },
            y: {
              display: true,
                   title: {
                     display: true,
                     text: 'Price (Scientific)',
                     color: '#ffffff',
                     font: {
                       size: 12
                     }
                   },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                },
                callback: function(value) {
                  const val = parseFloat(value);
                  return val.toExponential(2);
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              // Set min and max for real token price (1e-15)
              beginAtZero: false,
              min: 1e-15, // Start from 1e-15 (1000 wei)
              max: 1.2e-15  // Slightly above 1e-15 for better visualization
            }
          },
          elements: {
            line: {
              tension: 0.4
            }
          }
        }
      };

      try {
        tokenChart = new Chart(ctx, config);
        console.log('‚úÖ Token chart created with', prices.length, 'data points');
        console.log('üìä Chart configured for low prices:', {
          minPrice: minPrice,
          maxPrice: maxPrice,
          priceRange: priceRange
        });
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }
    
    // Create point chart
    async function createPointChart(canvas, history) {
      console.log('üîÑ Creating point chart with', history.length, 'data points');
      
      if (pointChart) {
        pointChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      
      // Use real data if available, otherwise generate sample data
      let labels = [];
      let prices = [];
      
      if (history && history.length > 0) {
        // Use real historical data from events
        labels = history.map(item => {
          const date = new Date(item.created_at);
          return date.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit' 
          });
        });
        prices = history.map(item => parseFloat(item.point_value_usd));
        console.log('üìä Using real historical data from events:', prices.length, 'data points');
      } else {
        // Get current price from getPointValue() and create history
        try {
          const currentPrice = await priceService.getRealPointPrice();
          const currentPriceValue = parseFloat(currentPrice.point_value_usd);
          
          // Create 6 data points with current price
          labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
          prices = [currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue, currentPriceValue];
          
          console.log('üìä Using current price from getPointValue():', currentPriceValue);
          console.log('üìä Chart will update automatically on point events (PointValueUpdated, BinaryPoolUpdated)');
        } catch (error) {
          console.warn('‚ö†Ô∏è Could not get current point price, using fallback:', error.message);
          // Fallback to 0
          labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
          prices = [0, 0, 0, 0, 0, 0];
        }
      }
      
      const data = {
          labels: labels,
          datasets: [{
          label: 'Point Price (USD) - Real Contract Data',
            data: prices,
            borderColor: '#a786ff',
            backgroundColor: 'rgba(167, 134, 255, 0.1)',
            borderWidth: 2,
            fill: true,
          tension: 0.4
        }]
      };
      
      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return '$' + parseFloat(context.raw).toFixed(2);
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              min: 0,
              ticks: {
                callback: function(value) {
                  return '$' + parseFloat(value).toFixed(2);
                }
              }
            }
          }
        }
      };
      
      try {
        pointChart = new Chart(ctx, config);
        console.log('‚úÖ Point chart created with', prices.length, 'data points');
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }
    
    // Show chart error
    function showChartError(canvas, message) {
      if (!canvas) return;
      
      const container = canvas.parentElement;
      container.innerHTML = `
        <div class="error">
          <div class="error-icon">‚ö†Ô∏è</div>
          <div>${message}</div>
        </div>
      `;
    }
    
    // Show general error
    function showError(message) {
      const container = document.querySelector('.container');
      const errorDiv = document.createElement('div');
      errorDiv.className = 'chart-card';
      errorDiv.innerHTML = `
        <div class="error">
          <div class="error-icon">‚ùå</div>
          <div>${message}</div>
        </div>
      `;
      container.appendChild(errorDiv);
    }
    
    
    
    // Format number with commas
    function formatNumber(num) {
      if (isNaN(num) || num === null || num === undefined) {
        return '0';
      }
      return new Intl.NumberFormat('en-US').format(num);
    }
    
        // Get token history from localStorage (global scope)
        window.getTokenHistoryFromStorage = function() {
          try {
            const history = localStorage.getItem('token_price_history');
            if (history) {
              const parsed = JSON.parse(history);
              // Keep only last 24 hours of data
              const now = Date.now();
              const oneDayAgo = now - (24 * 60 * 60 * 1000);
              return parsed.filter(item => new Date(item.timestamp).getTime() > oneDayAgo);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not get token history from localStorage:', error.message);
          }
          return [];
        };

        // Get point history from localStorage (global scope)
        window.getPointHistoryFromStorage = function() {
          try {
            const history = localStorage.getItem('point_value_history');
            if (history) {
              const parsed = JSON.parse(history);
              // Keep only last 24 hours of data
              const now = Date.now();
              const oneDayAgo = now - (24 * 60 * 60 * 1000);
              return parsed.filter(item => new Date(item.timestamp).getTime() > oneDayAgo);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not get point history from localStorage:', error.message);
          }
          return [];
        };
    
    // Save token price to localStorage history
    function saveTokenPriceToHistory(price) {
      try {
        const history = window.getTokenHistoryFromStorage();
        const newEntry = {
          price: price,
          timestamp: new Date().toISOString()
        };
        history.push(newEntry);
        
        // Keep only last 100 entries
        if (history.length > 100) {
          history.splice(0, history.length - 100);
        }
        
        localStorage.setItem('token_price_history', JSON.stringify(history));
        console.log('üìä Token price saved to history:', price);
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not save token price to history:', error.message);
      }
    }
    
    // Save point value to localStorage history
    function savePointValueToHistory(price) {
      try {
        const historyRaw = localStorage.getItem('point_value_history');
        const existing = historyRaw ? JSON.parse(historyRaw) : [];
        const newEntry = { price: price, timestamp: new Date().toISOString() };
        existing.push(newEntry);
        // Keep only last 100 entries
        if (existing.length > 100) {
          existing.splice(0, existing.length - 100);
        }
        localStorage.setItem('point_value_history', JSON.stringify(existing));
        console.log('üìä Point value saved to history:', price);
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not save point value to history:', error.message);
      }
    }

    // Merge and save token history ensuring no duplicates by ISO timestamp
    function mergeAndSaveTokenHistory(newItems) {
      try {
        const existing = window.getTokenHistoryFromStorage();
        const map = new Map();
        for (const it of existing) map.set(it.timestamp, it);
        for (const it of newItems) map.set(it.timestamp, it);
        const merged = Array.from(map.values()).sort((a,b)=>new Date(a.timestamp)-new Date(b.timestamp));
        localStorage.setItem('token_price_history', JSON.stringify(merged));
        console.log('üíæ Merged token history saved:', merged.length);
      } catch (e) {
        console.warn('‚ö†Ô∏è mergeAndSaveTokenHistory failed:', e?.message || e);
      }
    }

    // Seed initial (0.01 USD at t0) and current on-chain token price for immediate display
    async function seedInitialAndCurrentTokenHistory(provider, contractAddress) {
      try {
        const iface = new ethers.Interface(window.IAM_ABI);
        const Contract = new ethers.Contract(contractAddress, window.IAM_ABI, await provider.getSigner());
        // Initial price: $0.01 at t0 (e.g., 25 days ago)
        const initialDate = new Date();
        initialDate.setDate(initialDate.getDate() - 25);
        const initialEntry = { price: 0.01, timestamp: initialDate.toISOString() };

        // Current price from contract (getTokenPrice, 18 decimals)
        let currentPrice = 0;
        try {
          const priceWei = await Contract.getTokenPrice();
          currentPrice = Number(ethers.formatUnits(priceWei, 18));
        } catch (_) {
          // Fallback: keep 0 to avoid bad data
          currentPrice = 0;
        }
        const nowEntry = { price: currentPrice || 0.01, timestamp: new Date().toISOString() };

        mergeAndSaveTokenHistory([initialEntry, nowEntry]);

        // Update UI and charts immediately
        updateTokenStats({ price_usd: nowEntry.price });
        const tokenCanvas = document.getElementById('tokenChart');
        await loadTokenChartFromDatabase();
      } catch (e) {
        console.warn('‚ö†Ô∏è seedInitialAndCurrentTokenHistory failed:', e?.message || e);
      }
    }
    
    // Removed Neon clear/seed helpers
    
    // Contract-only mode end
  </script>
</body>
</html>
