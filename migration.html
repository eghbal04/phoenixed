<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migration Tool - Binary Tree Structure</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0f1c, #1a1f2e);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(26, 31, 46, 0.8);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(167, 134, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #a786ff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(167, 134, 255, 0.5);
        }

        .header p {
            color: #9ecbff;
            font-size: 1.1rem;
        }

        .status-card {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-card.error {
            background: rgba(255, 68, 68, 0.1);
            border-color: rgba(255, 68, 68, 0.3);
        }

        .status-card.warning {
            background: rgba(255, 193, 7, 0.1);
            border-color: rgba(255, 193, 7, 0.3);
        }

        .contract-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .contract-card {
            background: rgba(26, 31, 46, 0.6);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
        }

        .contract-card h3 {
            color: #a786ff;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .contract-address {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
            color: #9ecbff;
        }

        .migration-controls {
            background: rgba(26, 31, 46, 0.6);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .migration-controls h3 {
            color: #a786ff;
            margin-bottom: 20px;
            font-size: 1.4rem;
        }

        .btn {
            background: linear-gradient(135deg, #a786ff, #00ff88);
            color: #0a0f1c;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(167, 134, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc3333);
            color: #ffffff;
        }

        .btn.warning {
            background: linear-gradient(135deg, #ffc107, #ff8f00);
            color: #0a0f1c;
        }

        .progress-section {
            background: rgba(26, 31, 46, 0.6);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #a786ff, #00ff88);
            width: 0%;
            transition: width 0.3s ease;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(167, 134, 255, 0.1);
            font-family: monospace;
            font-size: 0.9rem;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ffc107;
        }

        .log-entry.info {
            color: #9ecbff;
        }

        .migration-stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(167, 134, 255, 0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(26, 31, 46, 0.6);
            border-radius: 6px;
            border: 1px solid rgba(167, 134, 255, 0.1);
        }

        .stat-label {
            color: #9ecbff;
            font-size: 0.9rem;
        }

        .stat-value {
            color: #a786ff;
            font-weight: 600;
            font-size: 1rem;
        }

        .stat-value.success {
            color: #00ff88;
        }

        .stat-value.error {
            color: #ff4444;
        }

        .comparison-table-section {
            background: rgba(26, 31, 46, 0.6);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .table-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 10px 8px;
            text-align: center;
            border: 1px solid rgba(167, 134, 255, 0.2);
        }

        .comparison-table th {
            background: rgba(167, 134, 255, 0.1);
            color: #a786ff;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .comparison-table td {
            color: #9ecbff;
        }

        .comparison-table tr:nth-child(even) {
            background: rgba(167, 134, 255, 0.05);
        }

        .status-success {
            color: #00ff88;
            font-weight: 600;
        }

        .status-error {
            color: #ff4444;
            font-weight: 600;
        }

        .status-pending {
            color: #ffc107;
            font-weight: 600;
        }

        .address-cell {
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
        }

        .user-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: rgba(26, 31, 46, 0.6);
            border: 1px solid rgba(167, 134, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
        }

        .info-card h4 {
            color: #a786ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-value {
            color: #9ecbff;
            font-size: 0.9rem;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .contract-info {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔄 Migration Tool</h1>
            <p>انتقال ساختار درخت باینری از قرارداد قدیم به جدید</p>
        </div>

        <div id="statusCard" class="status-card">
            <h3>📊 وضعیت سیستم</h3>
            <p id="statusText">در حال اتصال به کیف پول...</p>
        </div>

        <div class="contract-info">
            <div class="contract-card">
                <h3>📜 قرارداد قدیم</h3>
                <div class="contract-address" id="oldContractAddress">در حال بارگذاری...</div>
            </div>
            <div class="contract-card">
                <h3>🆕 قرارداد جدید</h3>
                <div class="contract-address" id="newContractAddress">در حال بارگذاری...</div>
            </div>
        </div>

        <div class="user-info" id="userInfo" style="display: none;">
            <div class="info-card">
                <h4>👤 آدرس کیف پول</h4>
                <div class="info-value" id="userAddress">-</div>
            </div>
            <div class="info-card">
                <h4>🌳 موقعیت در درخت</h4>
                <div class="info-value" id="userPosition">-</div>
            </div>
            <div class="info-card">
                <h4>👥 زیرمجموعه‌ها</h4>
                <div class="info-value" id="userChildren">-</div>
            </div>
            <div class="info-card">
                <h4>💰 موجودی IAM</h4>
                <div class="info-value" id="userBalance">-</div>
            </div>
        </div>

        <div class="migration-controls">
            <h3>🔄 کنترل‌های میگریشن</h3>
            <button id="exportSnapshotBtn" class="btn">📤 خروجی JSON شبکه</button>
            <input id="importSnapshotInput" type="file" accept="application/json" style="display:none" />
            <button id="importSnapshotBtn" class="btn">📥 ورود JSON شبکه</button>
            <button id="analyzeBtn" class="btn">🔍 تحلیل کامل ساختار درخت</button>
            <button id="migrateBtn" class="btn danger" disabled>🚀 شروع میگریشن کامل</button>
            <button id="verifyBtn" class="btn warning" disabled>✅ تأیید میگریشن کامل</button>
            <button id="resumeBtn" class="btn" disabled style="display: none;">🔄 ادامه میگریشن</button>
            <button id="skipErrorBtn" class="btn warning" disabled style="display: none;">⏭️ رد کردن خطا و ادامه</button>
        </div>

        <div class="progress-section" id="progressSection" style="display: none;">
            <h3>📈 پیشرفت میگریشن</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText">0% - آماده برای شروع</p>
            
            <div class="migration-stats" id="migrationStats" style="display: none;">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">کل کاربران:</span>
                        <span class="stat-value" id="totalUsersCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">میگریشن شده:</span>
                        <span class="stat-value success" id="migratedUsersCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ناموفق:</span>
                        <span class="stat-value error" id="failedUsersCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">در حال پردازش:</span>
                        <span class="stat-value" id="processingUsersCount">0</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="comparison-table-section" id="comparisonTableSection" style="display: none;">
            <h3>📊 جدول تطبیق کاربران</h3>
            <div class="table-container">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>ایندکس قدیم</th>
                            <th>آدرس قدیم</th>
                            <th>آدرس جدید</th>
                            <th>رفرر قدیم</th>
                            <th>رفرر جدید</th>
                            <th>وضعیت</th>
                        </tr>
                    </thead>
                    <tbody id="comparisonTableBody">
                    </tbody>
                </table>
            </div>
        </div>

        <div class="log-section">
            <h3>📝 گزارش عملیات</h3>
            <div id="logContainer">
                <div class="log-entry info">سیستم آماده است...</div>
            </div>
        </div>
    </div>

    <!-- Load config.js first -->
    <script src="js/config.js"></script>
    <script>
        class MigrationManager {
            constructor() {
                this.oldContract = null;
                this.newContract = null;
                this.signer = null;
                this.userAddress = null;
                this.treeStructure = null;
                this.isMigrating = false;
                this.migrationQueue = [];
                this.migratedUsers = new Set();
                this.failedUsers = new Set();
                this.totalUsers = 0;
                this.processedUsers = 0;
                this.visitedUsers = new Set();
                
                this.initialize();
            }

            async initialize() {
                try {
                    this.log('🔄 شروع فرآیند اتصال...', 'info');
                    
                    // Add a small delay to ensure MetaMask is ready
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    await this.connectWallet();
                    await this.setupContracts();
                    await this.loadUserData();
                    this.updateStatus('✅ سیستم آماده است', 'success');
                } catch (error) {
                    this.log(`❌ خطا در راه‌اندازی: ${error.message}`, 'error');
                    this.updateStatus('❌ خطا در راه‌اندازی سیستم', 'error');
                    
                    // Add retry button
                    this.addRetryButton();
                }
            }

            addRetryButton() {
                const statusCard = document.getElementById('statusCard');
                const retryBtn = document.createElement('button');
                retryBtn.textContent = '🔄 تلاش مجدد';
                retryBtn.className = 'btn';
                retryBtn.style.marginTop = '10px';
                retryBtn.onclick = () => {
                    retryBtn.remove();
                    this.initialize();
                };
                statusCard.appendChild(retryBtn);
            }

            async connectWallet() {
                try {
                    // Check if MetaMask is available
                    if (typeof window.ethereum === 'undefined') {
                        throw new Error('MetaMask یافت نشد - لطفاً MetaMask را نصب کنید');
                    }

                    // Check if MetaMask is locked
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (!accounts || accounts.length === 0) {
                            // Request account access
                            const newAccounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                            if (!newAccounts || newAccounts.length === 0) {
                                throw new Error('هیچ حساب کیف پولی یافت نشد - لطفاً MetaMask را باز کنید و حساب خود را انتخاب کنید');
                            }
                            this.userAddress = newAccounts[0];
                        } else {
                            this.userAddress = accounts[0];
                        }
                    } catch (requestError) {
                        if (requestError.code === 4001) {
                            throw new Error('کاربر اتصال را رد کرد - لطفاً دوباره تلاش کنید');
                        } else if (requestError.code === -32002) {
                            throw new Error('درخواست اتصال در حال پردازش است - لطفاً MetaMask را بررسی کنید');
                        } else {
                            throw new Error(`خطا در درخواست اتصال: ${requestError.message}`);
                        }
                    }

                    this.log(`✅ کیف پول متصل شد: ${this.userAddress.substring(0, 6)}...${this.userAddress.substring(38)}`, 'success');
                } catch (error) {
                    throw new Error(`خطا در اتصال کیف پول: ${error.message}`);
                }
            }

            async setupContracts() {
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    this.signer = await provider.getSigner();

                    // Wait for config to be loaded
                    if (!window.DEFAULT_IAM_ADDRESS || !window.SECOND_IAM_ADDRESS) {
                        this.log('⏳ در حال انتظار برای بارگذاری کانفیگ...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }

                    // Get contract addresses from config
                    const oldAddress = window.DEFAULT_IAM_ADDRESS;
                    const newAddress = window.SECOND_IAM_ADDRESS;

                    if (!oldAddress || !newAddress) {
                        throw new Error('آدرس‌های قرارداد در فایل کانفیگ یافت نشد - لطفاً صفحه را رفرش کنید');
                    }

                    // Update UI
                    document.getElementById('oldContractAddress').textContent = oldAddress;
                    document.getElementById('newContractAddress').textContent = newAddress;

                    // Create contract instances
                    this.oldContract = new ethers.Contract(oldAddress, window.IAM_ABI, this.signer);
                    this.newContract = new ethers.Contract(newAddress, window.IAM_ABI, this.signer);

                    this.log('✅ قراردادها آماده شدند', 'success');
                } catch (error) {
                    throw new Error(`خطا در راه‌اندازی قراردادها: ${error.message}`);
                }
            }

            async loadUserData() {
                try {
                    // Get user position in old contract
                    const userData = await this.oldContract.users(this.userAddress);
                    const userTree = await this.oldContract.getUserTree(this.userAddress);
                    
                    // Update UI
                    document.getElementById('userAddress').textContent = this.userAddress;
                    document.getElementById('userPosition').textContent = `شاخه ${userData.index.toString()}`;
                    document.getElementById('userChildren').textContent = `چپ: ${userTree.left}, راست: ${userTree.right}`;
                    
                    const balance = await this.oldContract.balanceOf(this.userAddress);
                    const balanceFormatted = ethers.formatUnits(balance, 18);
                    document.getElementById('userBalance').textContent = `${parseFloat(balanceFormatted).toFixed(6)} IAM`;

                    document.getElementById('userInfo').style.display = 'grid';
                    this.log('✅ اطلاعات کاربر بارگذاری شد', 'success');
                } catch (error) {
                    this.log(`⚠️ خطا در بارگذاری اطلاعات کاربر: ${error.message}`, 'warning');
                }
            }

            async analyzeTreeStructure() {
                try {
                    this.log('🔍 شروع تحلیل کامل ساختار درخت...', 'info');
                    
                    // Get total users count for reference (but don't use as limit)
                    this.totalUsers = await this.oldContract.wallets();
                    this.log(`📊 تعداد کل کاربران (مرجع): ${this.totalUsers.toString()}`, 'info');

                    // If a snapshot is loaded, use it; otherwise build by DFS
                    if (this.snapshot && Array.isArray(this.snapshot) && this.snapshot.length) {
                        this.log('🧩 استفاده از اسنپ‌شات بارگذاری‌شده برای ساخت نقشه ژنولوژی', 'info');
                        await this.loadSnapshotIntoState(this.snapshot);
                    } else {
                        this.log('🌳 در حال جستجوی کامل کاربران با DFS...', 'info');
                        await this.buildCompleteGenealogy();
                    }
                    
                    this.log('✅ تحلیل ساختار درخت تکمیل شد', 'success');
                    document.getElementById('migrateBtn').disabled = false;
                } catch (error) {
                    this.log(`❌ خطا در تحلیل ساختار: ${error.message}`, 'error');
                }
            }

            async exportSnapshot() {
                try {
                    // Ensure genealogy is built
                    if (!this.userIndexMap || this.userIndexMap.size === 0) {
                        this.log('ℹ️ ابتدا تحلیل درخت را انجام دهید تا اسنپ‌شات ساخته شود', 'info');
                        return;
                    }
                    const sortedIndices = Array.from(this.userIndexMap.keys()).sort((a,b)=>a-b);
                    const snapshot = [];
                    for (const idx of sortedIndices) {
                        const address = this.userIndexMap.get(idx);
                        const data = this.genealogyMap.get(address) || {};
                        snapshot.push({
                            index: idx,
                            address,
                            referrer: data.referrer || '0x0000000000000000000000000000000000000000'
                        });
                    }
                    const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `iam-network-snapshot-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                    this.log('📤 اسنپ‌شات JSON با موفقیت صادر شد', 'success');
                } catch (error) {
                    this.log(`❌ خطا در خروجی JSON: ${error.message}`, 'error');
                }
            }

            async importSnapshot(file) {
                try {
                    const text = await file.text();
                    const json = JSON.parse(text);
                    if (!Array.isArray(json)) throw new Error('فرمت JSON معتبر نیست');
                    this.snapshot = json;
                    await this.loadSnapshotIntoState(json);
                    this.log('📥 اسنپ‌شات JSON با موفقیت بارگذاری شد', 'success');
                    document.getElementById('migrateBtn').disabled = false;
                } catch (error) {
                    this.log(`❌ خطا در ورود JSON: ${error.message}`, 'error');
                }
            }

            async loadSnapshotIntoState(snapshotArray) {
                // Reset maps
                this.genealogyMap = new Map();
                this.userIndexMap = new Map();
                this.comparisonData = [];
                this.visitedUsers = new Set();
                for (const item of snapshotArray) {
                    if (!item || !item.index || !item.address) continue;
                    this.userIndexMap.set(Number(item.index), item.address);
                    this.genealogyMap.set(item.address, {
                        index: String(item.index),
                        referrer: item.referrer || '0x0000000000000000000000000000000000000000',
                        upper: item.referrer || '0x0000000000000000000000000000000000000000',
                        left: '0x0000000000000000000000000000000000000000',
                        right: '0x0000000000000000000000000000000000000000'
                    });
                    this.comparisonData.push({
                        oldIndex: Number(item.index),
                        oldAddress: item.address,
                        newAddress: null,
                        oldReferrer: item.referrer || '0x0000000000000000000000000000000000000000',
                        newReferrer: null,
                        status: 'pending'
                    });
                }
                this.updateComparisonTable();
            }

            async buildCompleteGenealogy() {
                try {
                    this.genealogyMap = new Map();
                    this.userIndexMap = new Map();
                    this.comparisonData = [];
                    this.visitedUsers = new Set();
                    
                    this.log(`🔍 شروع جستجوی DFS درخت باینری...`, 'info');
                    this.log(`📊 تعداد کاربران در قرارداد: ${this.totalUsers}`, 'info');
                    
                    // Start DFS from root user (index 1)
                    await this.dfsTraversal(1);
                    
                    // Check if we found all users from wallets variable
                    if (this.genealogyMap.size < this.totalUsers) {
                        this.log(`⚠️ هشدار: فقط ${this.genealogyMap.size} کاربر از ${this.totalUsers} کاربر wallets یافت شد`, 'warning');
                    } else if (this.genealogyMap.size > this.totalUsers) {
                        this.log(`ℹ️ اطلاعات: ${this.genealogyMap.size} کاربر یافت شد (بیشتر از ${this.totalUsers} wallets)`, 'info');
                    }
                    
                    this.log(`✅ جستجوی DFS پایان یافت: ${this.genealogyMap.size} کاربر یافت شد`, 'success');
                    this.updateComparisonTable();
                } catch (error) {
                    throw new Error(`خطا در ساخت نقشه ژنولوژی: ${error.message}`);
                }
            }

            async dfsTraversal(index) {
                try {
                    // Skip if already visited or invalid index
                    if (this.visitedUsers.has(index) || index <= 0) {
                        return;
                    }

                    // Get user address by index
                    const userAddress = await this.oldContract.indexToAddress(index);
                    
                    // Skip if address is empty
                    if (userAddress === '0x0000000000000000000000000000000000000000') {
                        return;
                    }

                    // Mark as visited
                    this.visitedUsers.add(index);

                    // Get referrer using getReferrer function with index
                    const referrerAddress = await this.oldContract.getReferrer(index);
                    
                    // Get user data (addresses left/right are not used for traversal)
                    const userData = await this.oldContract.users(userAddress);
                    
                    // Store user data
                    this.genealogyMap.set(userAddress, {
                        index: userData.index.toString(),
                        referrer: referrerAddress,
                        upper: referrerAddress, // Use referrer as upper
                        left: '0x0000000000000000000000000000000000000000',
                        right: '0x0000000000000000000000000000000000000000',
                        binaryPoints: userData.binaryPoints ? userData.binaryPoints.toString() : '0',
                        depositedAmount: userData.depositedAmount ? userData.depositedAmount.toString() : '0',
                        lastMonthlyClaim: userData.lastMonthlyClaim ? userData.lastMonthlyClaim.toString() : '0',
                        totalMonthlyRewarded: userData.totalMonthlyRewarded ? userData.totalMonthlyRewarded.toString() : '0',
                        refclimed: userData.refclimed ? userData.refclimed.toString() : '0'
                    });
                    
                    this.userIndexMap.set(index, userAddress);
                    
                    // Add to comparison data
                    this.comparisonData.push({
                        oldIndex: index,
                        oldAddress: userAddress,
                        newAddress: null,
                        oldReferrer: referrerAddress,
                        newReferrer: null,
                        status: 'pending'
                    });
                    
                    this.log(`✅ کاربر ایندکس ${index} یافت شد: ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`, 'success');
                    
                    // Recursively visit children by index with left-first priority
                    const leftIndex = await this.oldContract.getLeftChild(index);
                    const leftAddress = await this.oldContract.indexToAddress(Number(leftIndex));
                    if (leftAddress !== '0x0000000000000000000000000000000000000000') {
                        await this.dfsTraversal(Number(leftIndex));

                        // Only check right child if left exists (per register logic)
                        const rightIndex = await this.oldContract.getRightChild(index);
                        const rightAddress = await this.oldContract.indexToAddress(Number(rightIndex));
                        if (rightAddress !== '0x0000000000000000000000000000000000000000') {
                            await this.dfsTraversal(Number(rightIndex));
                        }
                    }
                    
                } catch (error) {
                    this.log(`⚠️ خطا در DFS برای ایندکس ${index}: ${error.message}`, 'warning');
                }
            }

            async startMigration() {
                if (this.isMigrating) return;
                
                this.isMigrating = true;
                document.getElementById('migrateBtn').disabled = true;
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('migrationStats').style.display = 'block';
                document.getElementById('comparisonTableSection').style.display = 'block';
                
                try {
                    this.log('🚀 شروع فرآیند میگریشن کامل...', 'info');
                    
                    // Build migration queue in correct order (by index)
                    await this.buildMigrationQueue();
                    
                    this.log(`📋 صف میگریشن ساخته شد: ${this.migrationQueue.length} کاربر (به ترتیب ایندکس)`, 'info');
                    
                    // Update statistics and table
                    this.updateMigrationStats();
                    this.updateComparisonTable();
                    
                    // Process migration queue
                    await this.processMigrationQueue();
                    
                    this.log('✅ میگریشن کامل با موفقیت تکمیل شد', 'success');
                    document.getElementById('verifyBtn').disabled = false;
                    // Hide skip error button when migration completes successfully
                    document.getElementById('skipErrorBtn').style.display = 'none';
                    
                } catch (error) {
                    this.log(`❌ خطا در میگریشن: ${error.message}`, 'error');
                    this.log(`⚠️ میگریشن متوقف شد، اما می‌توانید با دکمه "ادامه میگریشن" یا "رد کردن خطا" ادامه دهید`, 'warning');
                    document.getElementById('resumeBtn').style.display = 'inline-block';
                    document.getElementById('resumeBtn').disabled = false;
                    document.getElementById('skipErrorBtn').style.display = 'inline-block';
                    document.getElementById('skipErrorBtn').disabled = false;
                } finally {
                    this.isMigrating = false;
                    // Keep resume button enabled even after errors
                    document.getElementById('resumeBtn').disabled = false;
                }
            }

            async buildMigrationQueue() {
                try {
                    this.migrationQueue = [];
                    
                    // Build migration queue using all found users (sorted by index)
                    const sortedIndices = Array.from(this.userIndexMap.keys()).sort((a, b) => a - b);
                    
                    for (const index of sortedIndices) {
                        const userAddress = this.userIndexMap.get(index);
                        if (userAddress) {
                            this.migrationQueue.push({
                                index: index,
                                address: userAddress,
                                referrer: this.genealogyMap.get(userAddress).referrer
                            });
                        }
                    }
                    
                    this.log(`📋 صف میگریشن ساخته شد: ${this.migrationQueue.length} کاربر (به ترتیب ایندکس)`, 'info');
                } catch (error) {
                    throw new Error(`خطا در ساخت صف میگریشن: ${error.message}`);
                }
            }

            async processMigrationQueue() {
                try {
                    this.processedUsers = 0;
                    
                    for (const userInfo of this.migrationQueue) {
                        try {
                            const result = await this.migrateUser(userInfo);
                            this.migratedUsers.add(userInfo.address);
                            this.processedUsers++;
                            
                            // Update comparison data
                            this.updateComparisonData(userInfo.index, userInfo.address, result.newAddress, result.newReferrer, 'success');
                            
                            const progress = Math.round((this.processedUsers / this.migrationQueue.length) * 100);
                            this.updateProgress(progress, `در حال میگریشن کاربر ${this.processedUsers} از ${this.migrationQueue.length} (ایندکس ${userInfo.index})`);
                            
                            // Update statistics and table
                            this.updateMigrationStats();
                            this.updateComparisonTable();
                            
                            this.log(`✅ کاربر ایندکس ${userInfo.index} (${userInfo.address.substring(0, 6)}...${userInfo.address.substring(38)}) میگریشن شد`, 'success');
                            
                            // Add small delay to avoid overwhelming the network
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                        } catch (error) {
                            this.failedUsers.add(userInfo.address);
                            
                            // Update comparison data with error
                            this.updateComparisonData(userInfo.index, userInfo.address, null, null, 'error');
                            
                            this.log(`❌ خطا در میگریشن کاربر ایندکس ${userInfo.index} (${userInfo.address.substring(0, 6)}...${userInfo.address.substring(38)}): ${error.message}`, 'error');
                            
                            // Update statistics and table even on failure
                            this.updateMigrationStats();
                            this.updateComparisonTable();
                            
                            // Continue migration instead of stopping - log error and move to next user
                            this.log(`⚠️ رد شدن از کاربر ایندکس ${userInfo.index} و ادامه میگریشن...`, 'warning');
                            
                            // Add small delay before continuing
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    
                    this.updateProgress(100, 'میگریشن کامل شد');
                } catch (error) {
                    this.log(`❌ خطا در پردازش صف میگریشن: ${error.message}`, 'error');
                    this.log(`⚠️ میگریشن متوقف شد، اما می‌توانید با دکمه "ادامه میگریشن" ادامه دهید`, 'warning');
                }
            }

            async migrateUser(userInfo) {
                try {
                    const userAddress = userInfo.address;
                    const referrerAddress = userInfo.referrer;
                    
                    // Check if user already exists in new contract
                    const existingUser = await this.newContract.users(userAddress);
                    if (existingUser.index.toString() !== '0') {
                        this.log(`⚠️ کاربر ایندکس ${userInfo.index} (${userAddress.substring(0, 6)}...${userAddress.substring(38)}) قبلاً در قرارداد جدید وجود دارد`, 'warning');
                        
                        // Get new contract data for comparison
                        const newUserData = await this.newContract.users(userAddress);
                        const newUserTree = await this.newContract.getUserTree(userAddress);
                        
                        return {
                            newAddress: userAddress,
                            newReferrer: newUserTree.referrer
                        };
                    }
                    
                    // Register user in new contract using referrer as upper
                    if (referrerAddress !== '0x0000000000000000000000000000000000000000') {
                        // Pre-check with callStatic to capture revert reasons without spending gas
                        try {
                            await this.newContract.callStatic.registerAndActivate(
                                referrerAddress,
                                referrerAddress,
                                userAddress
                            );
                        } catch (preErr) {
                            const msg = (preErr && preErr.message) ? preErr.message : String(preErr);
                            if (msg.toLowerCase().includes('insufficient token balance')) {
                                this.log(`❌ ثبت‌نام ایندکس ${userInfo.index} ممکن نیست: موجودی توکن کافی نیست برای فعال‌سازی. قرارداد/کیف‌پول تامین مالی شود یا تنظیمات فعال‌سازی بررسی گردد.`, 'error');
                            } else {
                                this.log(`❌ پیش‌بررسی تراکنش ناموفق برای ایندکس ${userInfo.index}: ${msg}`, 'error');
                            }
                            throw new Error(msg);
                        }

                        // Send tx with manual gasLimit to bypass estimation errors (after successful callStatic)
                        const tx = await this.newContract.registerAndActivate(
                            referrerAddress, // referrer
                            referrerAddress, // upper (same as referrer)
                            userAddress,     // new user
                            { gasLimit: 1000000 }
                        );
                        await tx.wait();
                        
                        // Get new contract data after registration
                        const newUserData = await this.newContract.users(userAddress);
                        const newUserTree = await this.newContract.getUserTree(userAddress);
                        
                        this.log(`✅ کاربر ایندکس ${userInfo.index} (${userAddress.substring(0, 6)}...${userAddress.substring(38)}) در قرارداد جدید ثبت شد`, 'success');
                        
                        return {
                            newAddress: userAddress,
                            newReferrer: newUserTree.referrer
                        };
                    } else {
                        throw new Error(`کاربر ایندکس ${userInfo.index} رفرر ندارد - نمی‌توان ثبت نام کرد`);
                    }
                    
                } catch (error) {
                    throw new Error(`خطا در میگریشن کاربر ایندکس ${userInfo.index}: ${error.message}`);
                }
            }

            async verifyMigration() {
                try {
                    this.log('🔍 شروع تأیید میگریشن کامل...', 'info');
                    
                    let successCount = 0;
                    let failCount = 0;
                    
                    for (const userAddress of this.migrationQueue) {
                        try {
                            const newUserData = await this.newContract.users(userAddress);
                            if (newUserData.index.toString() !== '0') {
                                successCount++;
                            } else {
                                failCount++;
                                this.log(`❌ کاربر ${userAddress.substring(0, 6)}...${userAddress.substring(38)} در قرارداد جدید یافت نشد`, 'error');
                            }
                        } catch (error) {
                            failCount++;
                            this.log(`❌ خطا در تأیید کاربر ${userAddress.substring(0, 6)}...${userAddress.substring(38)}: ${error.message}`, 'error');
                        }
                    }
                    
                    this.log(`📊 نتایج تأیید: ${successCount} موفق، ${failCount} ناموفق`, 'info');
                    
                    if (failCount === 0) {
                        this.log('✅ میگریشن کامل تأیید شد', 'success');
                    } else {
                        this.log(`⚠️ میگریشن ناقص: ${failCount} کاربر ناموفق`, 'warning');
                    }
                    
                } catch (error) {
                    this.log(`❌ خطا در تأیید میگریشن: ${error.message}`, 'error');
                }
            }

            updateMigrationStats() {
                document.getElementById('totalUsersCount').textContent = this.migrationQueue.length;
                document.getElementById('migratedUsersCount').textContent = this.migratedUsers.size;
                document.getElementById('failedUsersCount').textContent = this.failedUsers.size;
                document.getElementById('processingUsersCount').textContent = this.processedUsers;
            }

            updateComparisonData(oldIndex, oldAddress, newAddress, newReferrer, status) {
                const data = this.comparisonData.find(item => item.oldIndex === oldIndex);
                if (data) {
                    data.newAddress = newAddress;
                    data.newReferrer = newReferrer;
                    data.status = status;
                }
            }

            updateComparisonTable() {
                const tbody = document.getElementById('comparisonTableBody');
                tbody.innerHTML = '';
                
                this.comparisonData.forEach(item => {
                    const row = document.createElement('tr');
                    
                    // Old Index
                    const oldIndexCell = document.createElement('td');
                    oldIndexCell.textContent = item.oldIndex;
                    row.appendChild(oldIndexCell);
                    
                    // Old Address
                    const oldAddressCell = document.createElement('td');
                    oldAddressCell.className = 'address-cell';
                    oldAddressCell.textContent = item.oldAddress ? `${item.oldAddress.substring(0, 6)}...${item.oldAddress.substring(38)}` : '-';
                    row.appendChild(oldAddressCell);
                    
                    // New Address
                    const newAddressCell = document.createElement('td');
                    newAddressCell.className = 'address-cell';
                    newAddressCell.textContent = item.newAddress ? `${item.newAddress.substring(0, 6)}...${item.newAddress.substring(38)}` : '-';
                    row.appendChild(newAddressCell);
                    
                    // Old Referrer
                    const oldReferrerCell = document.createElement('td');
                    oldReferrerCell.className = 'address-cell';
                    oldReferrerCell.textContent = item.oldReferrer && item.oldReferrer !== '0x0000000000000000000000000000000000000000' 
                        ? `${item.oldReferrer.substring(0, 6)}...${item.oldReferrer.substring(38)}` : '-';
                    row.appendChild(oldReferrerCell);
                    
                    // New Referrer
                    const newReferrerCell = document.createElement('td');
                    newReferrerCell.className = 'address-cell';
                    newReferrerCell.textContent = item.newReferrer && item.newReferrer !== '0x0000000000000000000000000000000000000000' 
                        ? `${item.newReferrer.substring(0, 6)}...${item.newReferrer.substring(38)}` : '-';
                    row.appendChild(newReferrerCell);
                    
                    // Status
                    const statusCell = document.createElement('td');
                    statusCell.className = `status-${item.status}`;
                    switch(item.status) {
                        case 'success':
                            statusCell.textContent = '✅ موفق';
                            break;
                        case 'error':
                            statusCell.textContent = '❌ خطا';
                            break;
                        case 'pending':
                            statusCell.textContent = '⏳ در انتظار';
                            break;
                        default:
                            statusCell.textContent = item.status;
                    }
                    row.appendChild(statusCell);
                    
                    tbody.appendChild(row);
                });
            }

            async resumeMigration() {
                if (this.isMigrating) return;
                
                this.isMigrating = true;
                document.getElementById('resumeBtn').disabled = true;
                document.getElementById('migrateBtn').disabled = true;
                
                try {
                    this.log('🔄 ادامه فرآیند میگریشن...', 'info');
                    
                    // Continue from where we left off
                    const remainingUsers = this.migrationQueue.filter(userInfo => 
                        !this.migratedUsers.has(userInfo.address) && !this.failedUsers.has(userInfo.address)
                    );
                    
                    this.log(`📋 ${remainingUsers.length} کاربر باقی‌مانده برای میگریشن`, 'info');
                    
                    // Process remaining users
                    for (const userInfo of remainingUsers) {
                        try {
                            const result = await this.migrateUser(userInfo);
                            this.migratedUsers.add(userInfo.address);
                            this.processedUsers++;
                            
                            // Update comparison data
                            this.updateComparisonData(userInfo.index, userInfo.address, result.newAddress, result.newReferrer, 'success');
                            
                            const progress = Math.round((this.processedUsers / this.migrationQueue.length) * 100);
                            this.updateProgress(progress, `در حال میگریشن کاربر ${this.processedUsers} از ${this.migrationQueue.length} (ایندکس ${userInfo.index})`);
                            
                            this.updateMigrationStats();
                            this.updateComparisonTable();
                            
                            this.log(`✅ کاربر ایندکس ${userInfo.index} (${userInfo.address.substring(0, 6)}...${userInfo.address.substring(38)}) میگریشن شد`, 'success');
                            
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                        } catch (error) {
                            this.failedUsers.add(userInfo.address);
                            
                            // Update comparison data with error
                            this.updateComparisonData(userInfo.index, userInfo.address, null, null, 'error');
                            
                            this.log(`❌ خطا در میگریشن کاربر ایندکس ${userInfo.index} (${userInfo.address.substring(0, 6)}...${userInfo.address.substring(38)}): ${error.message}`, 'error');
                            
                            this.updateMigrationStats();
                            this.updateComparisonTable();
                            
                            // Continue migration instead of stopping - log error and move to next user
                            this.log(`⚠️ رد شدن از کاربر ایندکس ${userInfo.index} و ادامه میگریشن...`, 'warning');
                            
                            // Add small delay before continuing
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    
                    this.updateProgress(100, 'میگریشن کامل شد');
                    this.log('✅ میگریشن کامل با موفقیت تکمیل شد', 'success');
                    document.getElementById('verifyBtn').disabled = false;
                    // Hide skip error button when migration completes successfully
                    document.getElementById('skipErrorBtn').style.display = 'none';
                    
                } catch (error) {
                    this.log(`❌ خطا در ادامه میگریشن: ${error.message}`, 'error');
                    this.log(`⚠️ میگریشن متوقف شد، اما می‌توانید با دکمه "ادامه میگریشن" یا "رد کردن خطا" ادامه دهید`, 'warning');
                    document.getElementById('skipErrorBtn').style.display = 'inline-block';
                    document.getElementById('skipErrorBtn').disabled = false;
                } finally {
                    this.isMigrating = false;
                    // Keep resume button enabled even after errors
                    document.getElementById('resumeBtn').disabled = false;
                }
            }

            async skipErrorAndContinue() {
                if (this.isMigrating) return;
                
                this.log('⏭️ رد کردن خطا و ادامه میگریشن...', 'info');
                
                // Simply call resumeMigration which now continues on errors
                await this.resumeMigration();
            }

            updateProgress(percentage, text) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = `${percentage}% - ${text}`;
            }

            updateStatus(message, type) {
                const statusCard = document.getElementById('statusCard');
                const statusText = document.getElementById('statusText');
                
                statusCard.className = `status-card ${type}`;
                statusText.textContent = message;
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.migrationManager = new MigrationManager();
            
            // Setup event listeners
            document.getElementById('exportSnapshotBtn').addEventListener('click', () => {
                window.migrationManager.exportSnapshot();
            });

            document.getElementById('importSnapshotBtn').addEventListener('click', () => {
                document.getElementById('importSnapshotInput').click();
            });

            document.getElementById('importSnapshotInput').addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    window.migrationManager.importSnapshot(file);
                    // reset input to allow same-file re-upload later if needed
                    e.target.value = '';
                }
            });
            document.getElementById('analyzeBtn').addEventListener('click', () => {
                window.migrationManager.analyzeTreeStructure();
            });
            
            document.getElementById('migrateBtn').addEventListener('click', () => {
                window.migrationManager.startMigration();
            });
            
            document.getElementById('verifyBtn').addEventListener('click', () => {
                window.migrationManager.verifyMigration();
            });
            
            document.getElementById('resumeBtn').addEventListener('click', () => {
                window.migrationManager.resumeMigration();
            });
            
            document.getElementById('skipErrorBtn').addEventListener('click', () => {
                window.migrationManager.skipErrorAndContinue();
            });
        });
    </script>
</body>
</html>

